<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gopherbot DevOps Chatbot</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="Title.html">Title</a></li><li class="expanded affix "><a href="Foreward.html">Foreward</a></li><li class="expanded affix "><a href="Introduction.html">Introduction</a></li><li class="expanded affix "><a href="Terminology.html">Terminology</a></li><li class="expanded "><a href="Installation.html"><strong aria-hidden="true">1.</strong> Gopherbot Software Installation</a></li><li><ol class="section"><li class="expanded "><a href="install/Requirements.html"><strong aria-hidden="true">1.1.</strong> Requirements</a></li><li class="expanded "><a href="install/ManualInstall.html"><strong aria-hidden="true">1.2.</strong> Manual Installation</a></li></ol></li><li class="expanded "><a href="Upgrading.html"><strong aria-hidden="true">2.</strong> Upgrading from Version 1</a></li><li><ol class="section"><li class="expanded "><a href="upgrade/BotInfo.html"><strong aria-hidden="true">2.1.</strong> Required Bot Info</a></li><li class="expanded "><a href="upgrade/External-Plugin.html"><strong aria-hidden="true">2.2.</strong> External Plugin Configuration</a></li><li class="expanded "><a href="upgrade/Custom-Dir.html"><strong aria-hidden="true">2.3.</strong> Custom Configuration Directory</a></li><li class="expanded "><a href="upgrade/robot-yaml.html"><strong aria-hidden="true">2.4.</strong> Main Configuration File Rename</a></li><li class="expanded "><a href="upgrade/Encryption.html"><strong aria-hidden="true">2.5.</strong> Early Encryption Initialization</a></li><li class="expanded "><a href="upgrade/Memories.html"><strong aria-hidden="true">2.6.</strong> Long-Term Memories</a></li></ol></li><li class="expanded "><a href="RobotInstall.html"><strong aria-hidden="true">3.</strong> Initial Robot Configuration</a></li><li><ol class="section"><li class="expanded "><a href="botsetup/Requirements.html"><strong aria-hidden="true">3.1.</strong> Requirements</a></li><li class="expanded "><a href="botsetup/ManualSetup.html"><strong aria-hidden="true">3.2.</strong> Manual Setup</a></li><li><ol class="section"><li class="expanded "><a href="botsetup/bothome.html"><strong aria-hidden="true">3.2.1.</strong> Create the GOPHER_HOME directory</a></li><li class="expanded "><a href="botsetup/initenv.html"><strong aria-hidden="true">3.2.2.</strong> Create the Initial .env File</a></li><li class="expanded "><a href="botsetup/initcrypt.html"><strong aria-hidden="true">3.2.3.</strong> Initialize Encryption</a></li><li class="expanded "><a href="botsetup/copystd.html"><strong aria-hidden="true">3.2.4.</strong> Copy the Standard Robot</a></li><li class="expanded "><a href="botsetup/sshkeys.html"><strong aria-hidden="true">3.2.5.</strong> Generate SSH Keypairs</a></li><li class="expanded "><a href="botsetup/finalenv.html"><strong aria-hidden="true">3.2.6.</strong> Finish the .env File</a></li><li class="expanded "><a href="botsetup/connect.html"><strong aria-hidden="true">3.2.7.</strong> Connect Robot to Team</a></li><li class="expanded "><a href="botsetup/saverobot.html"><strong aria-hidden="true">3.2.8.</strong> Saving Your Robot to Git</a></li><li class="expanded "><a href="botsetup/finished.html"><strong aria-hidden="true">3.2.9.</strong> Finished</a></li></ol></li><li class="expanded "><a href="botsetup/ContainerSetup.html"><strong aria-hidden="true">3.3.</strong> Setup with Containers</a></li><li class="expanded "><a href="botsetup/Plugin.html"><strong aria-hidden="true">3.4.</strong> Using the Setup Plugin</a></li><li class="expanded "><a href="botsetup/Gitpod.html"><strong aria-hidden="true">3.5.</strong> Setting up a Robot with Gitpod</a></li></ol></li><li class="expanded "><a href="RunRobot.html"><strong aria-hidden="true">4.</strong> Deploying and Running Your Robot</a></li><li><ol class="section"><li class="expanded "><a href="deploy/CLI.html"><strong aria-hidden="true">4.1.</strong> CLI Operation</a></li><li><ol class="section"><li class="expanded "><a href="deploy/local.html"><strong aria-hidden="true">4.1.1.</strong> Local Install</a></li><li class="expanded "><a href="deploy/containercli.html"><strong aria-hidden="true">4.1.2.</strong> Container Operation</a></li><li class="expanded "><a href="deploy/gitpodcli.html"><strong aria-hidden="true">4.1.3.</strong> Using Gitpod</a></li><li class="expanded "><a href="deploy/secrets.html"><strong aria-hidden="true">4.1.4.</strong> Encrypting Secrets</a></li></ol></li><li class="expanded "><a href="deploy/systemd.html"><strong aria-hidden="true">4.2.</strong> Running with Systemd</a></li><li class="expanded "><a href="deploy/Container.html"><strong aria-hidden="true">4.3.</strong> Running in a Container</a></li></ol></li><li class="expanded "><a href="Configuration.html"><strong aria-hidden="true">5.</strong> Configuring Gopherbot</a></li><li><ol class="section"><li class="expanded "><a href="Environment-Variables.html"><strong aria-hidden="true">5.1.</strong> Environment Variables</a></li><li class="expanded "><a href="config/file.html"><strong aria-hidden="true">5.2.</strong> Configuration File Loading</a></li><li class="expanded "><a href="config/job-plug.html"><strong aria-hidden="true">5.3.</strong> Job and Plugin Configuration</a></li><li class="expanded "><a href="config/troubleshooting.html"><strong aria-hidden="true">5.4.</strong> Troubleshooting</a></li></ol></li><li class="expanded "><a href="Admin.html"><strong aria-hidden="true">6.</strong> Administering Your Robot</a></li><li><ol class="section"><li class="expanded "><a href="usage/admin.html"><strong aria-hidden="true">6.1.</strong> Administrator Commands</a></li><li class="expanded "><a href="usage/cli.html"><strong aria-hidden="true">6.2.</strong> Command-Line Use</a></li><li class="expanded "><a href="usage/logging.html"><strong aria-hidden="true">6.3.</strong> Logging</a></li></ol></li><li class="expanded "><a href="api/API-Introduction.html"><strong aria-hidden="true">7.</strong> Gopherbot API</a></li><li><ol class="section"><li class="expanded "><a href="api/Languages.html"><strong aria-hidden="true">7.1.</strong> Language Templates</a></li><li class="expanded "><a href="api/Attribute-Retrieval-API.html"><strong aria-hidden="true">7.2.</strong> Attribute Retrieval</a></li><li class="expanded "><a href="api/Brain-API.html"><strong aria-hidden="true">7.3.</strong> Brain Methods</a></li><li class="expanded "><a href="api/Message-Sending-API.html"><strong aria-hidden="true">7.4.</strong> Message Sending</a></li><li class="expanded "><a href="api/Pipeline-API.html"><strong aria-hidden="true">7.5.</strong> Pipeline Construction</a></li><li class="expanded "><a href="api/Response-Request-API.html"><strong aria-hidden="true">7.6.</strong> Requesting Responses</a></li><li class="expanded "><a href="api/Utility-API.html"><strong aria-hidden="true">7.7.</strong> Utility</a></li></ol></li><li class="expanded "><a href="Modules.html"><strong aria-hidden="true">8.</strong> Module Support</a></li><li class="expanded "><a href="pipelines/jobspipes.html"><strong aria-hidden="true">9.</strong> Jobs and Pipelines</a></li><li><ol class="section"><li class="expanded "><a href="pipelines/tasks.html"><strong aria-hidden="true">9.1.</strong> Included Tasks</a></li><li class="expanded "><a href="pipelines/TaskEnvironment.html"><strong aria-hidden="true">9.2.</strong> Task Environment Variables</a></li><li class="expanded "><a href="pipelines/integrations.html"><strong aria-hidden="true">9.3.</strong> Tool Integrations</a></li><li class="expanded "><a href="pipelines/ssh.html"><strong aria-hidden="true">9.4.</strong> Integrating with SSH</a></li></ol></li><li class="expanded "><a href="GopherDev.html"><strong aria-hidden="true">10.</strong> Working on Gopherbot</a></li><li><ol class="section"><li class="expanded "><a href="botdev/DevelRobot.html"><strong aria-hidden="true">10.1.</strong> Development Robot</a></li><li class="expanded "><a href="botdev/IntegrationTests.html"><strong aria-hidden="true">10.2.</strong> Integration Tests</a></li><li class="expanded "><a href="botdev/Gitpod.html"><strong aria-hidden="true">10.3.</strong> Coding with Gitpod</a></li><li class="expanded "><a href="botdev/StructsInterfaces.html"><strong aria-hidden="true">10.4.</strong> Important Structs and Interfaces</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Gopherbot DevOps Chatbot</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#gopherbotbrdevops-chatbot" id="gopherbotbrdevops-chatbot">Gopherbot</br>DevOps Chatbot</a></h1>
<p><img src="gopherbot.png" alt="Gophers+bot by Renee French, cropped, cc3.0" /></p>
<p>By David Parsley, <a href="mailto:parsley@linuxjedi.org">parsley@linuxjedi.org</a></p>
<p><strong>NOTE: This manual is a work in progress; currently incomplete and partly outdated. This note will be removed for the 2.0 release - for now YMMV.</strong></p>
<p>Gophers + Robot by Renee French (cropped) licensed under <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons License 3.0</a></p>
<p>My work with ChatOps began with Hubot around 2012 when I was working as an systems engineer for a small hosting provider. The owner had sent me a link to Hubot, asking me to have a look. I took to the concept immediately, and started automating all kinds of tasks that our support team could easily access from our team chat. Soon they were using our robot to troubleshoot email routing and DNS issues, migrate mailboxes, and build new cPanel server instances.</p>
<p>Not being a very talented (or motivated) Javascript/NodeJS programmer, my Hubot commands invariably followed the same pattern: write it in Javascript if it was <em>trivially</em> easy  to do so, otherwise shell out to bash and return the results. This was productive and gave results, but it was ugly and limited in functionality.</p>
<p>When I began teaching myself Go, I needed a good project to learn with. After my experience with Hubot, I decided to write a robot that was more approachable for Systems and DevOps engineers like myself - tasked with providing functionality most easily accessible from e.g. bash or python scripts. Towards that end, Gopherbot's design:</p>
<ul>
<li>Is CGI-like in operation: the compiled server process spawns scripts which can then use a simple API for interacting with the user / chat service</li>
<li>Supports any number of scripting languages by using a simple json-over-http localhost interface</li>
<li>Uses a multi-process design with method calls that block</li>
</ul>
<p>Ultimately, Gopherbot gives me a strong alternative to writing Yet Another Web Application to deliver some kind of reporting, security, or management functionality to managers and technical users. It's a good meet-in-the-middle solution that's nearly as easy to use as a web application, with some added benefits:</p>
<ul>
<li>The chat application gives you a single pane of glass for access to a wide range of functionality</li>
<li>The shared-view nature of channels gives an added measure of security thanks to visibility, and also a simple means of training users to interact with a given application</li>
<li>Like a CGI, applications can focus on functionality, with security and access control being configured in the server process</li>
</ul>
<p>It is my hope that this design will appeal to other engineers like myself, and that somewhere, somebody will exclaim &quot;Wait, what? I can write chat bot plugins <em><strong>in BASH</strong></em>?!?&quot;</p>
<p>David Parsley, March 2017 / September 2019</p>
<pre><code class="language-bash">#!/bin/bash

# echo.sh - trivial shell plugin example for Gopherbot

# START Boilerplate
[ -z &quot;$GOPHER_INSTALLDIR&quot; ] &amp;&amp; { echo &quot;GOPHER_INSTALLDIR not set&quot; &gt;&amp;2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat &lt;&lt;&quot;EOF&quot;
---
Help:
- Keywords: [ &quot;repeat&quot; ]
  Helptext: [ &quot;(bot), repeat (me) - prompt for and trivially repeat a phrase&quot; ]
CommandMatchers:
- Command: &quot;repeat&quot;
  Regex: '(?i:repeat( me)?)'
EOF
}

case &quot;$command&quot; in
# NOTE: only &quot;configure&quot; should print anything to stdout
	&quot;configure&quot;)
		configure
		;;
	&quot;repeat&quot;)
		REPEAT=$(PromptForReply SimpleString &quot;What do you want me to repeat?&quot;)
		RETVAL=$?
		if [ $RETVAL -ne $GBRET_Ok ]
		then
			Reply &quot;Sorry, I had a problem getting your reply: $RETVAL&quot;
		else
			Reply &quot;$REPEAT&quot;
		fi
		;;
esac
</code></pre>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p><strong>Gopherbot</strong> DevOps Chatbot is a tool for teams of developers, operators, infrastructure engineers and support personnel - primarily for those that are already using Slack or another team chat platform for day-to-day communication. It belongs to and integrates well with a larger family of tools including <em>Ansible</em>, <em>git</em> and <em>ssh</em>, and is able to perform many tasks similar to <em>Jenkins</em> or <em>TravisCI</em>; all of this functionality is made available to your team via the chat platform you're already using.</p>
<p>To help give you an idea of the kinds of tasks you can accomplish, here are a few of the things my teams have done with <strong>Gopherbot</strong> over the years:</p>
<ul>
<li>Generating and destroying <a href="https://aws.amazon.com">AWS</a> instances on demand</li>
<li>Running software build, test and deploy pipelines, triggered by git service integration with team chat</li>
<li>Updating service status on the department website</li>
<li>Allowing support personnel to search and query user attributes</li>
<li>Running scheduled backups to gather artifacts over <code>ssh</code> and publish them to an artifact service</li>
<li>Occasionally - generating silly memes</li>
</ul>
<p>The primary strengths of <strong>Gopherbot</strong> stem from it's simplicity and flexibility. It installs and bootstraps readily on a VM or in a container with just a few environment variables, and can be run behind a firewall where it can perform tasks like rebooting server hardware over IPMI. Simple command plugins can be written in <code>bash</code> or <code>python</code>, with easy to use encrypted secrets for accomplishing privileged tasks. Like any user, the robot can also have it's own (encrypted, naturally) ssh key for performing remote work and interfacing with <em>git</em> services.</p>
<p>The philosophy underlying <strong>Gopherbot</strong> is the idea of solving the most problems with the smallest set of general purpose tools, accomplishing a wide variety of tasks reasonably well. It's true that <strong>Gopherbot</strong> doesn't do CI/CD to the level of, say, <em>Jenkins</em> - but it's amazing how productive I am with it. Perhaps the best example of it's flexibility can be seen in the CI/CD pipeline for <strong>Gopherbot</strong> itself; start reading with <code>pipeline.sh</code> in <a href="https://github.com/lnxjedi/gopherbot/tree/master/.gopherci">the <code>.gopherci</code> directory</a>.</p>
<p>The major design goals for <strong>Gopherbot</strong> are reliability and portability, leaning heavily on &quot;configuration as code&quot;. Ideally, custom add-on plugins and jobs that work for a robot instance in <a href="https://slack.com">Slack</a> should work just as well if your team moves, say, to <a href="https://rocket.chat">Rocket.Chat</a>. This goal ends up being a trade-off with supporting specialized features of a given platform, though the <strong>Gopherbot</strong> API enables platform-specific customizations if desired.</p>
<p>Secondary but important design goals are configurability and security. Individual commands can be constrained to a subset of channels and/or users, requiring external authorization or elevation plugins, and administrators can customize help and command matching patterns for stock plugins. <strong>Gopherbot</strong> has been built with security considerations in mind from the start; employing strong encryption, privilege separation, and a host of other measures to make your robot a difficult target.</p>
<p>Version 2 for the most part assumes that your robot will employ encryption and get it's configuration from a <em>git</em> repository. Other deployments are possible, but not well documented. This manual will focus on working with <strong>Gopherbot</strong> instances whose configuration is stored on <a href="https://github.com">Github</a>, but other <em>git</em> services are easy to use, as well.</p>
<p>That's it for the &quot;marketing&quot; portion of this manual - by now you should have an idea whether <strong>Gopherbot</strong> would be a good addition to your DevOps tool set.</p>
<h1><a class="header" href="#terminology" id="terminology">Terminology</a></h1>
<p>This section is most important for referring back to as you read the documentation, to disambiguate terms.</p>
<p>(It's also for me, to help maintain some consistency)</p>
<ul>
<li><strong>Gopherbot</strong> - The installed software archive that comprises the <strong>Gopherbot DevOps Chatbot</strong> service daemon</li>
<li><strong>robot</strong> - you'll see the term <em>robot</em> in several different contexts in the documentation with these several meanings:
<ul>
<li><strong>robot</strong> - A configured instance of a running <strong>Gopherbot</strong> daemon, available in your team chat; normally associated with a <em>git</em> repository that holds all the configuration and extensions for the robot</li>
<li><strong>Robot</strong> - The object passed to user plugins, jobs and tasks</li>
<li><strong>robot</strong> - the <strong>Go</strong> library for loadable modules, i.e. <code>import github.com/lnxjedi/robot</code></li>
</ul>
</li>
<li><strong>default robot</strong> - If you run Gopherbot with no custom configuration, you get <em>Floyd</em>, the default robot</li>
<li><strong>standard robot</strong> - A standard robot is what you get from using <code>robot.skel</code> or running the <code>setup</code> plugin from the <strong>default robot</strong>; more generally, any robot that has the standard <code>robot.skel</code> configuration as it's base is still a <strong>standard robot</strong></li>
<li><strong>GOPHER_HOME</strong> - The top-level directory for a given robot; the <strong>Gopherbot</strong> binary (<code>/opt/gopherbot/gopherbot</code>) is run from this directory to start or interact with the robot</li>
<li><strong>bootstrapping</strong> - A major goal of <strong>Gopherbot</strong> version 2 was first-class container support; when you start the <code>gopherbot</code> daemon in a container with a few environment variables, or in an empty directory with a suitable <code>.env</code> environment file, the <strong>bootstrap</strong> plugin will use a deploy key to pull your robot from a <em>git</em> repository and start it up - this process is called <strong>bootstrapping your robot</strong></li>
<li><strong>plugin</strong> (or <strong>command plugin</strong>) - A piece of code that provides new commands or code for authorization and/or elevation</li>
<li><strong>authorizer</strong> - special plugin command used to determine whether a given user is authorized for a given command, normally checking some kind of group membership</li>
<li><strong>elevator</strong> - special plugin command providing additional verification of user identity; this can be as simple as a totp token or <a href="https://duo.com">Duo</a> two-factor, or as complex as prompting another user before allowing a command to proceed</li>
<li><strong>job</strong> - jobs are pieces of code that typically use the pipeline API for creating pipelines to perform complex scheduled tasks such as backups and monitoring, or for software builds that may be triggered by hosted git service integrations with your chat platform; see the chapter on <a href="pipelines/jobspipes.html">jobs and pipelines</a></li>
<li><strong>task</strong> - tasks are small pieces of code that generally form the parts of a pipeline, such as initializing (and tearing down) the <code>ssh-agent</code>, running pipeline scripts, or sending notifications; the task is also the base object for jobs and plugins, so &quot;task&quot; may refer to any entry in <code>ExternalPlugins</code>, <code>ExternalTasks</code>, <code>ExternalJobs</code>, etc.</li>
<li><strong>parameter</strong> - a name/value setting configurable for tasks, plugins, jobs and repositories, presented to external scripts as environment variables</li>
</ul>
<p>In addition, this manual may periodically reference two important robots:</p>
<ul>
<li><strong>Floyd</strong> - Floyd is the production robot in the <code>linuxjedi</code> Slack team, currently running on a <code>t2.nano</code> in AWS. Floyd is responsible for building, testing and publishing the <strong>Gopherbot</strong> artifacts. The name is taken from Infocom's <strong>Planetfall</strong>, circa 1983. Also, as above, the <strong>Gopherbot</strong> default robot is named <em>Floyd</em>, but every other mention of <strong>Floyd</strong> refers to my production robot, whose repository can always be found <a href="https://github.com/parsley42/floyd-gopherbot">on Github</a>.</li>
<li><strong>Clu</strong> - Clu is &quot;the best program that's ever been written ... dogged and relentless&quot;; also, the development robot that changes frequently as I develop <strong>Gopherbot</strong>. Clu runs on workstations, chromebooks, containers, in <a href="https://www.gitpod.io/">Gitpod</a>, or wherever I happen to be doing development. If you've seen <strong>Tron: Legacy</strong> - it's not <strong>THAT</strong> Clu, but rather the short-lived <strong>Clu</strong> from the original <strong>TRON</strong>, circa 1982. <strong>Clu's</strong> repository is also always available <a href="https://github.com/parsley42/clu-gopherbot">on Github</a>, and generally has a pretty up-to-date README (not so much Floyd).</li>
</ul>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>There are three distinct tasks involved in installing and running a <strong>Gopherbot</strong> robot:</p>
<ul>
<li>This chapter discusses installing the <strong>Gopherbot</strong> distribution archive, normally in <code>/opt/gopherbot</code>, providing the <code>gopherbot</code> binary, default configuration, and an assortment of included batteries (libraries, plugins, jobs, tasks, helper scripts and more); if you're using a <a href="https://hub.docker.com/r/lnxjedi/gopherbot">Gopherbot container</a>, this is essentially a no-op.</li>
<li>Configuring a runnable instance of a robot for your team; the included <strong>setup</strong> plugin should make this an &quot;easy button&quot; - discussed in the chapter on <a href="RobotInstall.html">Initial Configuration</a>.</li>
<li>Deploying and running your robot on a server, VM, or in a container - covered in the chapter on <a href="RunRobot.html">Running your Robot</a>.</li>
</ul>
<h1><a class="header" href="#requirements" id="requirements">Requirements</a></h1>
<p>Since <strong>Gopherbot</strong> is primarily a <em>Go</em> daemon that utilizes external tools and scripts to perform most of the real work, you'll probably want to have most of the (common) listed dependencies. Note that if you deploy your robot in a container, most of these are included in the base container.</p>
<ul>
<li><code>git</code> - with version 2, <strong>Gopherbot</strong> is tightly integrated with git for updating configuration and keeping state; <strong>Gopherbot</strong> requires fairly recent versions of <em>git</em> supporting <code>git remote get-url ...</code>
<ul>
<li>Note that the version of <em>git</em> in CentOS 7 is not supported, see the <a href="https://ius.io/">Inline with Upstream Stable</a> site for a newer version</li>
</ul>
</li>
<li><code>ssh</code> - most robots should have an encrypted private key / public key pair for performing <em>git</em> operations and running remote jobs</li>
<li><code>bash</code> - the majority of the <em>batteries included</em> scripts included with <strong>Gopherbot</strong> are written in good 'ol <strong>Bash</strong>; this is nearly universal but listed here for containerized deployments</li>
<li><code>jq</code> - required by the <code>gopherbot/lib/gopherbot_v1.sh</code> <strong>bash</strong> library for parsing the <strong>JSON</strong> responses from the robot
<ul>
<li>Note this is available from the <a href="https://fedoraproject.org/wiki/EPEL">EPEL</a> repositories for CentOS 7</li>
</ul>
</li>
<li><code>python</code> - (version 3) next to <code>bash</code>, the second most common language for extensions is <strong>python</strong> version 3, which includes several management jobs</li>
</ul>
<p><strong>Optional</strong></p>
<ul>
<li><code>ruby</code> - ruby isn't heavily used with the default extensions, but is a supported language and included the pre-built containers</li>
<li><code>go</code> - the pre-built containers all include a recent version of <em>Go</em>, which can be used for e.g. building loadable modules for <em>Go</em> plugins, jobs and tasks</li>
</ul>
<h1><a class="header" href="#installing-the-gopherbot-software-archive" id="installing-the-gopherbot-software-archive">Installing the <code>gopherbot</code> software archive</a></h1>
<p>The latest release, pre-release and beta versions are available for download on the <a href="https://github.com">Github</a> releases page for <a href="https://github.com/lnxjedi/gopherbot/releases">gopherbot</a>.</p>
<ol>
<li>As <strong>root</strong>, download the <code>.tar.gz</code> or <code>.zip</code> archive of your choice, and extract the archive in <code>/opt</code> to create <code>/opt/gopherbot</code>, e.g.:</li>
</ol>
<pre><code class="language-shell">[root]# cd /opt
[opt]# wget https://github.com/lnxjedi/gopherbot/releases/download/v2.0.0-snapshot/gopherbot-linux-amd64.tar.gz
[opt]# tar xzf gopherbot-linux-amd64.tar.gz
</code></pre>
<ol start="2">
<li>(Optional) Also as root, make the <code>gopherbot</code> binary <strong>setuid nobody</strong> (see <a href="install/ManualInstall.html#privilege-separation">below</a>):</li>
</ol>
<pre><code class="language-shell">[opt]# chown nobody gopherbot/gopherbot
[opt]# chmod u+s gopherbot/gopherbot
</code></pre>
<h2><a class="header" href="#archive-contents" id="archive-contents">Archive Contents</a></h2>
<p><strong>Files</strong>]</p>
<ul>
<li><code>gopherbot</code> - the main executable, both a <em>CLI</em> and <em>daemon</em></li>
<li><code>fetch-robot.sh</code> - a utility script for retrieving a robot for local development</li>
</ul>
<p><strong>Directories</strong></p>
<ul>
<li><code>connectors/</code> - loadable modules for protocol connectors, e.g. <em>slack</em></li>
<li><code>goplugins/</code> - loadable modules for non-default <em>Go</em> plugins</li>
<li><code>brains/</code> - lodable modules for non-default brain implementations</li>
<li><code>conf/</code> - the default configuration, overridden by individual robots</li>
<li><code>lib/</code> - API libraries for <code>bash</code>, <code>python</code> and <code>ruby</code></li>
<li><code>plugins/</code> - external script plugins</li>
<li><code>plugins/samples</code> - sample plugins that show API usage but aren't otherwise useful</li>
<li><code>tasks/</code> - a collection of pipeline task scripts</li>
<li><code>jobs/</code> - a collection of jobs for robot management (backup/restore) and CI/CD</li>
<li><code>helpers/</code> - helper scripts not directly called by the robot</li>
<li><code>resources/</code> - miscellaneous useful bits for a running robot, also <em>Dockerfiles</em></li>
<li><code>doc/</code> - the source for the documentation on <a href="https://lnxjedi.github.io/gopherbot/">github pages</a></li>
<li><code>robot.skel/</code> - the initial configuration for new robots</li>
<li><code>licenses/</code> - licenses for other packages used by <strong>Gopherbot</strong>, as required</li>
</ul>
<h1><a class="header" href="#privilege-separation" id="privilege-separation">Privilege Separation</a></h1>
<p><strong>Gopherbot</strong> need never run as root; all of it's privileges derive from the collection of encrypted secrets that a given robot collects. However, given that chat bots tend to accumulate an assortment of 3rd-party command plugins (like the included <strong>Chuck Norris</strong>, hell yeah), <strong>Gopherbot</strong> can be installed <em>setuid nobody</em>. This will cause the robot to run with a <code>umask</code> of <code>0022</code>, and external plugins will run by default as real/effective user <code>nobody</code>. Since <strong>Gopherbot</strong> child processes do not inherit environment from the parent daemon, this effectively prevents any potential access to the <code>GOPHER_ENCRYPTION_KEY</code>, and any ability to modify the robot's running environment.</p>
<blockquote>
<p><strong>NOTE!</strong> Be wary of a false sense of security! The process still retains it's primary GID and supplementary groups, so if e.g. your robot unix user belongs to the <code>wheel</code> group, external scripts running as <code>nobody</code> will still be able to <code>sudo</code>. Privilege separation is just a simple means of providing additional hardening for your robot's execution environment.</p>
</blockquote>
<h1><a class="header" href="#upgrading-from-version-1" id="upgrading-from-version-1">Upgrading from Version 1</a></h1>
<p>The following sections detail the required and optional changes for upgrading a robot from version 1 to version 2. Over the course of developing version 2, there were several intermediary states for different configuration options that are not described here. If you need information on upgrading from any of these intermediary states, please <a href="https://github.com/lnxjedi/gopherbot/issues/new">open an issue</a>.</p>
<h1><a class="header" href="#required-bot-info" id="required-bot-info">Required Bot Info</a></h1>
<p>Earlier versions of <strong>Gopherbot</strong> expected to get info about the robot - name, handle, etc. - from the protocol connector; however, that can't be counted on. For your robot to respond to a command like <code>floyd, ping</code>, it will need a minimal <code>BotInfo</code> section in <code>robot.yaml</code>:</p>
<pre><code class="language-yaml">BotInfo:
  UserName: floyd
</code></pre>
<p>To provide other information about the robot to the <code>GetBotAttribute()</code> method, you might want to fill out the entire structure:</p>
<pre><code class="language-yaml">BotInfo:
  UserName: floyd
  Email: floyd@linuxjedi.org
  FullName: Floyd Gopherbot
  FirstName: Floyd
  LastName: Gopherbot
</code></pre>
<p>The robot's single-character <code>Alias</code> is still specified by itself, as before; e.g. <code>Alias: &quot;;&quot;</code>.</p>
<h1><a class="header" href="#external-plugin-configuration" id="external-plugin-configuration">External Plugin Configuration</a></h1>
<p>ExternalPlugins were formerly a list, but are now a hash, so:</p>
<pre><code class="language-yaml">ExternalPlugins:
- Name: chuck
  Path: plugins/chuck.rb
</code></pre>
<p>becomes:</p>
<pre><code class="language-yaml">ExternalPlugins:
  &quot;chuck&quot;:
    Path: plugins/chuck.rb
</code></pre>
<p>This allows all default configuration in the installation to be flexibly modified for a particular robot, using the new configuration merging.</p>
<h1><a class="header" href="#custom-configuration-directory" id="custom-configuration-directory">Custom Configuration Directory</a></h1>
<p>Version 2's configuration layout is heavily oriented towards an all-in-one robot directory, <code>$GOPHER_HOME</code>, with brain, job logs, workspaces, and others as subdirectories. It standardizes the location of the custom configuration directory (repository) to <code>$(pwd)/custom</code> (a.k.a. <code>$GOPHER_HOME/custom</code>). While setting the location with <code>-c &lt;dir&gt;</code> or via the <code>GOPHER_CONFIGDIR</code> environment variable are still supported, existing installations should locate custom configuration in a directory named <code>custom/</code>, with the robot started from the parent directory. See the <a href="upgrade/../InstallOverview.html">Installation Overview</a> for more information on the standard directory structure.</p>
<p>If your configuration is already in a repository, and the previous updates have already been made, then you can probably just run <code>/opt/gopherbot/gopherbot</code> from an empty directory and use the new setup plugin to bootstrap your robot.</p>
<h2><a class="header" href="#optional-rename-of-gopherbotyaml" id="optional-rename-of-gopherbotyaml">Optional rename of <code>gopherbot.yaml</code></a></h2>
<p>Version 2 defaults to <code>robot.yaml</code> for the name of the main configuration file for your robot. For backwards-compatibility, gopherbot will fall back to <code>gopherbot.yaml</code>.</p>
<h1><a class="header" href="#main-configuration-file-rename" id="main-configuration-file-rename">Main Configuration File Rename</a></h1>
<p>To make naming more consistent, <strong>Gopherbot</strong> v2 and the standard robot now expect to find <code>conf/robot.yaml</code> for the robot's main configuration file. It should still fall back to the old <code>conf/gopherbot.yaml</code> if <code>robot.yaml</code> isn't present, but for maximum forward-compatibility the old <code>gopherbot.yaml</code> should be renamed.</p>
<h2><a class="header" href="#early-encryption-initialization" id="early-encryption-initialization">Early Encryption Initialization</a></h2>
<p><strong>Gopherbot</strong> uses two separate keys for encrypting and decrypting secret data:</p>
<ul>
<li>The start-up key, normally 32 printable <code>ASCII</code> characters, used only for decrypting the binary, 32-byte random encryption key</li>
<li>The permanent runtime encryption key, 32 random bytes generated on the first run </li>
</ul>
<p>In version 1 and early snapshots of version 2, the runtime key was stored in the brain, and encryption was only initialized after the robot's brain provider and protocol connector. Secrets for these had to be provided in the environment, or unencrypted in <code>robot.yaml</code>. Version 2 addresses this by storing the binary encrypted runtime key in a <code>base64</code> encoded file, <code>custom/binary-encrypted-key</code>. This allows storing encrypted values for e.g. the <em>slack token</em> or <em>AWS credentials</em> in <code>robot.yaml</code>, and only needing to provide the start-up <code>GOPHER_ENCRYPTION_KEY</code> in the environment, or in an external environment file - <code>$GOPHER_HOME/.env</code> or <code>$GOPHER_HOME/private/environment</code>.</p>
<p>For a robot instance with a file-backed brain, the following command can be used to generate the version 2 key file:</p>
<pre><code class="language-bash">$ cat /path/to/brain/bot:encryptionKey | base64 -w 0 &gt; /path/to/custom/binary-encrypted-key
</code></pre>
<p>This file can then be committed to the custom configuration repository.</p>
<h2><a class="header" href="#default-brain-encryption" id="default-brain-encryption">Default Brain Encryption</a></h2>
<p>In version 2, <strong>Gopherbot</strong> defaults to an encrypted brain, which requires a <code>GOPHER_ENCRYPTION_KEY</code> to be set. To run your robot without brain encryption, you need to explicitly turn it off in your custom <code>robot.yaml</code>:</p>
<pre><code class="language-yaml">EncryptBrain: false
</code></pre>
<h1><a class="header" href="#long-term-memories" id="long-term-memories">Long-Term Memories</a></h1>
<p>Version 1 robots allowed long-term memory keys to contain <code>:</code> in the name, now disallowed as it is used as an internal separator. Memories with this character will need to be renamed, and plugins will need to be updated.</p>
<h1><a class="header" href="#initial-configuration" id="initial-configuration">Initial Configuration</a></h1>
<p>This chapter discusses the process of setting up a new <strong>Gopherbot</strong> robot to connect to your team chat. Even if you use the <code>setup</code> plugin to create your new robot, you may want to read the section on manual installation for the technical detail it provides.</p>
<h1><a class="header" href="#robot-requirements" id="robot-requirements">Robot Requirements</a></h1>
<p>To set up your robot you'll need:</p>
<ul>
<li>Access to a Linux host with the <strong>Gopherbot</strong> software installed, or an environment where you can run and interact with the <a href="https://hub.docker.com/repository/docker/lnxjedi/gopherbot">official Gopherbot container image</a>
<ul>
<li>If you've signed up for an account on <a href="https://gitpod.io">Gitpod</a> (free accounts available), you can set up a new robot with the online <a href="https://gitpod.io/#https://github.com/lnxjedi/gopherbot">Gopherbot Gitpod Demo</a></li>
</ul>
</li>
<li>Credentials your robot can use to log in to your team chat; you can obtain a <strong>Gopherbot</strong>-compatible <a href="https://slack.com">Slack</a> token here: https://&lt;team-name&gt;.slack.com/services/new/bot</li>
<li>The name of a channel where your robot will run jobs by default, e.g. <code>clu-jobs</code> or <code>floyd-jobs</code></li>
<li>A completely empty (no README, LICENSE, etc.) public or private <em>git</em> repository, to store your robot, normally <em>botname</em>-gopherbot; for example you can find <strong>Clu</strong> at <a href="https://github.com/parsley42/clu-gopherbot">https://github.com/parsley42/clu-gopherbot</a></li>
<li>If you're using a container and/or the <strong>autosetup plugin</strong>, you'll need to be able to configure a read/write deploy key for the robot's repository - this is widely supported with almost all of the major <em>git</em> hosting services and applications, check your repository settings or consult the documentation for your particular service</li>
</ul>
<blockquote>
<p>Note on Deploy Keys: If you are unfamiliar with ssh deploy keys, you should take a few minutes to read your git provider's documentation. A standard <em>Gopherbot</em> robot uses two deploy keys which are dedicated for use only with the robot's repository.</p>
</blockquote>
<p>The other requirements listed here are mainly items for consideration before setting up your <strong>Gopherbot</strong> robot.</p>
<h2><a class="header" href="#git-access" id="git-access">Git Access</a></h2>
<p><strong>Gopherbot</strong> version 2 integrates heavily with <em>git</em>, using <em>ssh</em> as the authentication mechanism. This guide and the setup plugin require a <em>git</em> repository that your robot can push to it with it's encrypted management ssh key (<code>manage_key</code>), which will be set up as a read-write deployment key. In addition to saving it's initial configuration to this repository, the standard robot configured with this guide will back up it's long-term memories to a separate <code>robot-state</code> branch.</p>
<blockquote>
<p>Note: The standard robot configured with this guide will have THREE DIFFERENT SSH KEYS, with the following uses:</p>
<ul>
<li>A dedicated encrypted <code>manage_key</code>, configured as a read-write deploy key for the robot's git repository; the robot will use this for saving it's initial configuration and backing up it's long-term memories from the <code>state/</code> directory</li>
<li>An unencrypted, read-only <code>deploy_key</code> that can be used for deploying your robot to e.g. a container or new VM</li>
<li>A default encrypted <code>robot_key</code> which the robot will use for all other CI/CD and remote ssh jobs; this is the key that should be associated with a git user, or machine user</li>
</ul>
</blockquote>
<p>Additionally, you may want to take advantage of <strong>Gopherbot</strong>'s CI/CD funcationality or ability to run git-driven jobs, which can be scheduled and/or on-demand; for example, <strong>Floyd</strong> updates the <code>gh-pages</code> branch of <a href="https://github.com/lnxjedi/gopherbot">lnxjedi/gopherbot</a> and also the <a href="https://github.com/lnxjedi">gopherbot-docker</a> repository after a successful build - see <a href="https://github.com/lnxjedi/gopherbot/blob/master/.gopherci/pipeline.sh">gopherbot/.gopherci/pipeline.sh</a>. It's worth considering how you'll set up your robot to access <em>git</em> repositories.</p>
<h3><a class="header" href="#machine-users" id="machine-users">Machine Users</a></h3>
<p>It's a good idea to create a machine account for your robot with the <em>git</em> service of your choice. Both <a href="https://github.com/floyd42">Floyd</a> and <a href="https://github.com/clu49">Clu</a> have machine accounts and belong to the <a href="https://github.com/lnxjedi">lnxjedi</a> organization on <a href="https://github.com">Github</a>. Having an organization and adding robots to teams makes it easy to provide flexible read/write access to repositories without having to jump through repository collaborator hoops.</p>
<h3><a class="header" href="#deploy-keys" id="deploy-keys">Deploy Keys</a></h3>
<p><em>Github</em>, at least, allows you to associate unique ssh deploy keys with a single repository, and even grant read-write access. The limitation of one repository per key pair increases administration overhead, and makes your robot's life more difficult. Though not fully documented here, it's possible to do this with <strong>Gopherbot</strong> by carefully managing the <code>KEYNAME</code> and <code>BOT_SSH_PHRASE</code> parameters (environment variables). See the section on <a href="botsetup/../pipelines/TaskEnvironment.html">task environment variables</a> for more information on parameter precedence.</p>
<p>The standard setup uses a read-write deploy key because it is the easiest means of configuring your robot initially, compatible with private repositories.</p>
<h3><a class="header" href="#user-ssh-keys" id="user-ssh-keys">User SSH Keys</a></h3>
<p>Git services also allow you to add multiple ssh keys to an individual user. It's also possible to add your robot's <code>robot_key.pub</code>, allowing your robot read-write access to all the repositories you have access to. This is the least recommended means of providing <em>git</em> repository write access for your robot, but may be the most expedient.</p>
<h2><a class="header" href="#brain-storage" id="brain-storage">Brain Storage</a></h2>
<p><strong>Gopherbot</strong> supports the notion of long-term memories, which are technically just key-blob stores. The included <code>lists</code> and <code>links</code> plugins both use long-term memory storage.</p>
<h3><a class="header" href="#file-backed-brains" id="file-backed-brains">File backed brains</a></h3>
<p>The standard configuration for a new robot uses the file-backed brain, with memories stored in <code>$GOPHER_HOME/state/brain</code>. You can schedule the included <code>backup</code> job to run periodically, and by default your robot will commit new memories as they're updated to a separate <code>robot-state</code> branch of it's configuration repository. If you want to store state in a separate repository, you can configure the <code>GOPHER_STATE_REPOSITORY</code> and optionally <code>GOPHER_STATE_BRANCH</code> for the included <code>backup</code> and <code>restore</code> jobs.</p>
<h3><a class="header" href="#dynamodb-brains" id="dynamodb-brains">DynamoDB brains</a></h3>
<p>As of this writing, the <a href="https://aws.amazon.com/">AWS</a> free tier provides a very generous 25GB of free DynamoDB storage - far more than any reasonable robot should use. See the section on <a href="botsetup/TODO">configuring the DynamoDB brain</a>.</p>
<h1><a class="header" href="#manual-setup" id="manual-setup">Manual Setup</a></h1>
<p>This section documents manual setup of a new robot custom configuration repository, using a Linux system or VM with the <strong>Gopherbot</strong> software <a href="botsetup/../install/ManualInstall.html">already installed</a>. Note that the documentation will often refer to a robot's <em>configuration repository</em>, even though using a <em>git</em> repository isn't strictly required.</p>
<blockquote>
<p>Note: This manual in general, and this section in particular, is not written as a complete step-by-step guide. Rather more of an outline, it skips a lot of e.g. <code>mkdir</code>, <code>sudo</code>, etc. If you're somewhat new to Linux systems administration, but have some experience with containers (e.g. <a href="https://www.docker.com/">Docker</a>), you might get more from the chapter on <a href="botsetup/DockerSetup.html">Setup with Docker</a>. If you've signed up for a free <a href="https://gitpod.io">Gitpod</a> account, you can set up a new robot with the online <a href="https://gitpod.io/#https://github.com/lnxjedi/gopherbot">Gopherbot Gitpod Demo</a>.</p>
</blockquote>
<h1><a class="header" href="#create-the-gopher_home-directory" id="create-the-gopher_home-directory">Create the GOPHER_HOME directory</a></h1>
<p>Similar to an <a href="https://www.ansible.com/">Ansible</a> playbook, a <strong>Gopherbot</strong> robot is heavily oriented around a standard directory structure for a given robot. To begin with, create an empty directory for your robot; <code>/var/lib/robots</code> or <code>/home/robots</code> are good places for this. I normally name the directory after the robot; in this example setup, we'll use <code>clu</code>:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots$ mkdir clu
davidparsley@penguin:/home/robots$ cd clu/
davidparsley@penguin:/home/robots/clu$ ln -s /opt/gopherbot/gopherbot .
</code></pre>
<blockquote>
<p>Note that we've created a symlink to the <strong>Gopherbot</strong> binary for convenience, and this is required for the rest of this chapter.</p>
</blockquote>
<h1><a class="header" href="#create-the-initial-env-file" id="create-the-initial-env-file">Create the Initial .env File</a></h1>
<p>Though it's possible to run <strong>Gopherbot</strong> with neither encryption nor a <em>git</em> repository, this example documents the more common scenario. To begin with, create a <code>.env</code> file in your new directory with contents similar to the following:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ echo &quot;GOPHER_ENCRYPTION_KEY=SomeLongStringAtLeast32CharsOrItWillFail&quot; &gt; .env
</code></pre>
<p>Note that the robot will only use the first 32 chars of the encryption key, so no need to go crazy here. Keep your <code>GOPHER_ENCRYPTION_KEY</code> in a safe place, outside of any git repository. Your robot will need it, along with <code>$GOPHER_HOME/custom/binary-encrypted-key</code> (kept in the robot's repository), to decrypt it's secrets - such as a Slack token.</p>
<h1><a class="header" href="#initialize-encryption" id="initialize-encryption">Initialize Encryption</a></h1>
<p>Now that you've set the robot's encryption key, you can initialize encryption and create the binary key (<code>binary-encrypted-key</code>) encrypted with your <code>GOPHER_ENCRYPTION_KEY</code>. Start the default robot using the terminal connector, and the binary encryption key will be automatically created in <code>custom/binary-encrypted-key</code>; use <code>ctrl-d</code> to exit:</p>
<pre><code>davidparsley@penguin:/home/robots/clu$ ./gopherbot 
2020/03/09 18:29:43 Logging to robot.log; warnings and errors duplicated to stdout
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
general: *******
general: Welcome to the *Gopherbot* terminal connector. Since no configuration was detected, you're
connected to 'floyd', the default robot.
general: If you've started the robot by mistake, just hit ctrl-D to exit and try 'gopherbot --help';
otherwise feel free to play around with the default robot - you can start by typing 'help'.
c:general/u:alice -&gt; exit
general: @alice Hasta la vista!
Terminal connector finished
davidparsley@penguin:/home/robots/clu$ ls custom/
binary-encrypted-key
</code></pre>
<h1><a class="header" href="#copy-and-modify-the-standard-robot" id="copy-and-modify-the-standard-robot">Copy and Modify the Standard Robot</a></h1>
<p>Now copy the contents of <code>robot.skel</code> from the distribution archive to the new <code>custom/</code> directory:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ cp -a /opt/gopherbot/robot.skel/* /opt/gopherbot/robot.skel/.??* custom/
</code></pre>
<blockquote>
<p>Note the <code>.??*</code> wildcard picks up any hidden files</p>
</blockquote>
<h3><a class="header" href="#41-encrypting-your-slack-token-and-other-secrets" id="41-encrypting-your-slack-token-and-other-secrets">4.1 Encrypting your Slack Token (and other secrets)</a></h3>
<p>With encryption initialized, you can use the <code>gopherbot encrypt</code> command to generate base64 encoded ciphertext. This ciphertext can then be placed in your configuration <code>yaml</code> files by using e.g. <code>{{ decrypt &quot;jfhPe8akfivTRnfeCxyIetdUl+Jb7hIWnjeVFiwLJarFHuW4TuSD7GQ3F0s2puuZ3JUotw==&quot; }}</code>. The default configuration assumes you'll only encrypt the portion of your slack token (from https://&lt;org&gt;.slack.com/services/new/bot) following the common <code>xoxb-</code> prefix. So, for a slack token of <code>xoxb-123-abc-XXXXX</code>, you would generate the ciphertext with:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ ./gopherbot encrypt 123-abc-XXXXX
FverBqdWHzHfEPDy/cQ8U9AJ3z4v8KdGSubDMALPfHIupwDLctDWQ1c=
</code></pre>
<p>(Note that we use <code>-l robot.log</code> to send some superfluous error messages to a log file)</p>
<p>Now edit your <code>conf/slack.yaml</code> file and replace <code>&lt;slackencrypted&gt;</code> with the ciphertext, e.g.:</p>
<pre><code class="language-yaml">  SlackToken: xoxb-{{ decrypt &quot;FverBqdWHzHfEPDy/cQ8U9AJ3z4v8KdGSubDMALPfHIupwDLctDWQ1c=&quot; }}
</code></pre>
<h3><a class="header" href="#42-editing-standard-configuration" id="42-editing-standard-configuration">4.2 Editing Standard Configuration</a></h3>
<p>Now you need to edit the configuration files under <code>custom/</code>, replacing most of the <code>&lt;replacevalue&gt;</code> instances with values for your robot.</p>
<p>In <code>custom/conf/robot.yaml</code>:</p>
<ul>
<li>Replace <code>&lt;botname&gt;</code> with the name of your robot, e.g. <code>clu</code></li>
<li>Replace <code>&lt;botemail&gt;</code> with an email address for your robot; will be used for &quot;from:&quot;</li>
<li>Replace <code>&lt;botfullname&gt;</code> with a full name, informational only; e.g. &quot;Clu Gopherbot&quot;</li>
<li>Replace <code>&lt;botalias&gt;</code> with a single-character alias for addressing your robot from the list <code>'&amp;!;:-%#@~&lt;&gt;/*+^\$?\[]{}'</code> (&quot;;&quot; is good for this)</li>
<li>Replace <code>&lt;sshencrypted&gt;</code> encrypted ciphertext for a 16+ char ssh passphrase for your robot, generated with <code>./gopherbot encrypt</code> as above</li>
</ul>
<p>In <code>custom/conf/slack.yaml</code>:</p>
<ul>
<li>Leave alone for now; you'll replace <code>&lt;adminusername&gt;</code> and <code>&lt;adminuserid&gt;</code> later, after your robot has successfully connected</li>
</ul>
<p>In <code>custom/conf/terminal.yaml</code>:</p>
<ul>
<li>Replace <code>&lt;botalias&gt;</code> with your robot's single-character alias</li>
</ul>
<p>In <code>custom/git/config</code>, replace the values for <code>&lt;botfullname&gt;</code> and <code>&lt;botemail&gt;</code>; these will be used when your robot performs a <code>git commit</code>.</p>
<h1><a class="header" href="#generate-ssh-keypairs" id="generate-ssh-keypairs">Generate SSH Keypairs</a></h1>
<p>Now generate the ssh keypairs for your robot - use the passphrase you encrypted previously for generating both <code>manage_key</code> and <code>robot_key</code>; finally create an unencrypted <code>deploy_key</code> and move it out of the repo:</p>
<pre><code class="language-shell">davidparsley@penguin:/home/robots/clu$ mkdir custom/ssh
davidparsley@penguin:/home/robots/clu$ ssh-keygen -N &quot;VeryLovelyNicePassword&quot; -C &quot;clu@linuxjedi.org&quot; -f custom/ssh/manage_key
Generating public/private rsa key pair.
Your identification has been saved in custom/ssh/manage_key.
Your public key has been saved in custom/ssh/manage_key.pub.
The key fingerprint is:
...
davidparsley@penguin:/home/robots/clu$ ssh-keygen -N &quot;VeryLovelyNicePassword&quot; -C &quot;clu@linuxjedi.org&quot; -f custom/ssh/robot_key
Generating public/private rsa key pair.
Your identification has been saved in custom/ssh/robot_key.
Your public key has been saved in custom/ssh/robot_key.pub.
The key fingerprint is:
...
davidparsley@penguin:/home/robots/clu$ ssh-keygen -N &quot;&quot; -C &quot;clu@linuxjedi.org&quot; -f custom/ssh/deploy_key
Generating public/private rsa key pair.
Your identification has been saved in custom/ssh/deploy_key.
Your public key has been saved in custom/ssh/deploy_key.pub.
The key fingerprint is:
...
davidparsley@penguin:/home/robots/clu$ mv custom/ssh/deploy_key .
</code></pre>
<blockquote>
<p>Note that deploy_key is unencrypted, and not kept in the robot's repository which is rooted in the <code>custom</code> directory.</p>
</blockquote>
<h1><a class="header" href="#finish-the-env-file" id="finish-the-env-file">Finish the <code>.env</code> File</a></h1>
<p>First, use <code>tr</code> to dump a flattened version of the <code>deploy_key</code> private key to the <code>.env</code> file:</p>
<pre><code>$ cat custom/ssh/deploy_key | tr ' \n' '_:' &gt;&gt; .env
</code></pre>
<p>Now edit the <code>.env</code> file and stick <code>GOPHER_DEPLOY_KEY=</code> in front of that mess, and add values for <code>GOPHER_PROTOCOL</code> and <code>GOPHER_CUSTOM_REPOSITORY</code>. Using <strong>Clu</strong> as an example, the end result should look something like this:</p>
<pre><code>GOPHER_ENCRYPTION_KEY=&lt;redacted&gt;
GOPHER_PROTOCOL=slack
GOPHER_CUSTOM_REPOSITORY=git@github.com:parsley42/clu-gopherbot.git
GOPHER_DEPLOY_KEY=-----BEGIN_OPENSSH_PRIVATE_KEY-----:lksjflsjdf&lt;muchjunkremoved&gt;ljsdflsjdf:-----END_OPENSSH_PRIVATE_KEY-----:
</code></pre>
<blockquote>
<p>Note that <code>GOPHER_DEPLOY_KEY</code> is a very long line, a bit over 2k. The format with spaces and newlines replaced was chosen as most compatible with the shell, docker, and <code>.env</code>-reading libraries.</p>
</blockquote>
<h1><a class="header" href="#connect-robot-to-team" id="connect-robot-to-team">Connect Robot to Team</a></h1>
<p>Now your robot should be able to connect to team chat, and respond to your messages:</p>
<pre><code class="language-shell">davidparsley@penguin:~/git/clu$ GOPHER_PROTOCOL=slack ./gopherbot 
2020/02/19 15:50:00 Initialized logging ...
2020/02/19 15:50:00 Loaded initial private environment from '.env'
...
2020/02/19 15:50:20 Info: Robot is initialized and running
</code></pre>
<p>Now you can <code>/invite</code> your robot to the <code>#general</code> channel, and get the information you need from Slack to configure yourself as the robot's administrator:</p>
<pre><code>#general me-&gt; clu, whoami
#general clu-&gt; You are 'Slack' user 'parsley/U0JLW8EMS', speaking in channel 'general/C0JLW8EP6', email address: parsley@linuxjedi.org
</code></pre>
<p>Given this reply, you would replace <code>&lt;adminusername&gt;</code> with <code>parsley</code> and <code>&lt;adminuserid&gt;</code> with <code>U0JLW8EMS</code> in <code>custom/conf/slack.yaml</code>. Now you can stop the robot with <code>ctrl-c</code> and restart with access to administrative commands.</p>
<h1><a class="header" href="#saving-your-robot-to-git" id="saving-your-robot-to-git">Saving Your Robot to Git</a></h1>
<p>At this point the contents of <code>custom/</code> should be committed to a git repository, and your robot should be run with <code>GOPHER_CUSTOM_REPOSITORY=&lt;clone-url&gt;</code>, where the <code>clone-url</code> is for use with ssh credentials. You can perform this step manually, or set up your robot's deploy keys and let the robot save it's own configuration.</p>
<h2><a class="header" href="#configuring-deploy-keys" id="configuring-deploy-keys">Configuring Deploy Keys</a></h2>
<p>As noted in <a href="botsetup/Requirements.html#git-access">requirements</a>, the standard robot has three ssh keypairs by default, two of which are configured as deploy keys for the repository.</p>
<p>Find the <strong>deploy keys</strong> section for the robot's git repository, then:</p>
<ul>
<li>Configure a <strong>read-write</strong> deploy key with the contents of <code>custom/ssh/manage_key.pub</code>; this corresponds to the encrypted <code>manage_key</code> the robot can use to save it's own configuration, or back up it's state / brain</li>
<li>Configure a <strong>read-only</strong> deploy key with the contents of <code>custom/ssh/deploy_key.pub</code>; this corresponds to the unencrypted <code>GOPHER_DEPLOY_KEY</code> in the <code>.env</code> file, and the gopherbot <strong>bootstrap</strong> plugin can use this to deploy your robot to e.g. a generic container or new VM</li>
</ul>
<p>Once you've set up the deploy keys, open a private chat with your robot and tell it to <code>save</code>; if all has gone well, your robot will push the contents of <code>custom/</code> to it's git repository, and should be ready to go.</p>
<p>This setup allows for a common workflow where the robot is running in a container, VM, or server in your infrastructure, and updates to robot configuration are made by updating the robot's configuration repository, followed by an administrator <code>update</code> command, (e.g. <code>clu, update</code>). The <code>update</code> command will cause the robot to <code>git pull</code> it's custom configuration, then perform a reload and report any errors.</p>
<h1><a class="header" href="#finished" id="finished">Finished</a></h1>
<p>That's it! You've created the initial configuration for your <strong>Gopherbot</strong> robot, which you can now customize and deploy.</p>
<h1><a class="header" href="#setup-with-containers" id="setup-with-containers">Setup with Containers</a></h1>
<p>If you have an environment where you can run and interact with containers in a terminal window, using either <a href="https://www.docker.com/">Docker</a> or <a href="https://podman.io/">Podman</a>, you can supply an answerfile for using the <strong>autosetup</strong> plugin in a container.</p>
<h2><a class="header" href="#getting-answerfiletxt" id="getting-answerfiletxt">Getting <code>answerfile.txt</code></a></h2>
<p>For container-based installs, you'll have to download the appropriate answerfile for your protocol. These can be found in <a href="https://github.com/lnxjedi/gopherbot/tree/master/resources/answerfiles">resources/answerfiles</a>; save as <code>answerfile.txt</code>.</p>
<p>You can download directly with <code>wget</code>:</p>
<pre><code class="language-shell">$ wget -O answerfile.txt https://raw.githubusercontent.com/lnxjedi/gopherbot/master/resources/answerfiles/slack.txt
</code></pre>
<p>Once you have your <code>answerfile.txt</code> you'll need to edit the file and set appropriate values for each <code>ANS_*</code> variable appropriate to your robot. Take care to use an unquoted value for <code>ANS_ROBOT_ALIAS</code>.</p>
<h2><a class="header" href="#starting-the-autosetup-plugin" id="starting-the-autosetup-plugin">Starting the <em>autosetup</em> plugin</a></h2>
<p>With a complete answerfile, you can start a <em>Gopherbot</em> container, passing the answerfile in for the environment. After the <em>autosetup</em> plugin runs and generates configuration, it'll pause and provide instructions for completing setup.</p>
<p><strong>With Podman</strong>:</p>
<pre><code>$ podman run -it --env-file answerfile.txt lnxjedi/gopherbot:latest
Trying to pull docker.io/lnxjedi/gopherbot:latest...
Getting image source signatures
...
Info: PID == 1, spawning child
Info: Starting pid 1 signal handler
Info: Logging to robot.log
null connector: Initializing encryption and restarting...
Info: Logging to robot.log
null connector: Continuing automatic setup...
...
</code></pre>
<p><strong>With Docker</strong>:</p>
<pre><code>$ docker run -it --env-file answerfile.txt lnxjedi/gopherbot:latest
Unable to find image 'lnxjedi/gopherbot:latest' locally
latest: Pulling from lnxjedi/gopherbot
...
Info: PID == 1, spawning child
Info: Starting pid 1 signal handler
Info: Logging to robot.log
null connector: Initializing encryption and restarting...
Info: Logging to robot.log
null connector: Continuing automatic setup...
...
</code></pre>
<h2><a class="header" href="#finishing-up" id="finishing-up">Finishing Up</a></h2>
<p>After your robot has successfully saved it's configuration to it's <em>git</em> repository, you can press <code>&lt;ctrl-c&gt;</code> to stop the container, then remove it. Your robot is now ready to be <a href="botsetup/../RunRobot.html">deployed</a>.</p>
<h1><a class="header" href="#using-the-setup-plugin" id="using-the-setup-plugin">Using the Setup Plugin</a></h1>
<p>If you've installed the [Gopherbot software] on a Linux host or VM, you can just create an empty directory and run the <code>gopherbot</code> binary to start the default robot and use the <strong>setup</strong> plugin:</p>
<pre><code>[~]$ mkdir clu
[~]$ cd clu/
[clu]$ ln -s /opt/gopherbot/gopherbot .
[clu]$ ./gopherbot 
2020/02/20 10:02:48 Debug: Checking os.Stat for dir 'custom' from wd '': stat custom: no such file or directory
2020/02/20 10:02:48 Debug: Checking os.Stat for dir 'conf' from wd '': stat conf: no such file or directory
2020/02/20 10:02:48 Warning: Starting unconfigured; no robot.yaml/gopherbot.yaml found
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
c:general/u:alice -&gt; 2020/02/20 10:02:49 Warning: GOPHER_CUSTOM_REPOSITORY not set, not bootstrapping
general: *******
general: Welcome to the *Gopherbot* terminal connector. Since no configuration was detected, you're
connected to 'floyd', the default robot.
general: If you've started the robot by mistake, just hit ctrl-D to exit and try 'gopherbot --help';
otherwise feel free to play around with the default robot - you can start by typing 'help'. If you'd
like to start configuring a new robot, type: ';setup'.
c:general/u:alice -&gt; ;setup
...
</code></pre>
<h1><a class="header" href="#setting-up-a-robot-with-gitpod" id="setting-up-a-robot-with-gitpod">Setting up a Robot with Gitpod</a></h1>
<p><a href="https://gitpod.io">Gitpod</a> is an online development environment with a generous free offering for use with public free software projects. You can use <strong>Gitpod</strong> to configure a new robot, or to develop <strong>Gopherbot</strong> on your own fork. Once you've signed up for an account, you can use the <strong>setup</strong> plugin from the <a href="https://gitpod.io/#https://github.com/lnxjedi/gopherbot">Gitpod Online Demo</a>:</p>
<pre><code>############################################################################
Welcome to the Gopherbot Demo. This will run Gopherbot
in terminal connector mode, where you can use the setup
plugin to configure a new robot and store it in a git
repository.
############################################################################

2020/02/20 15:06:57 Debug: Checking os.Stat for dir 'custom' from wd '': stat custom: no such file or directory
2020/02/20 15:06:57 Debug: Checking os.Stat for dir 'conf' from wd '': stat conf: no such file or directory
2020/02/20 15:06:57 Warning: Starting unconfigured; no robot.yaml/gopherbot.yaml found
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
c:general/u:alice -&gt; 2020/02/20 15:06:58 Warning: GOPHER_CUSTOM_REPOSITORY not set, not bootstrapping
general: *******
general: Welcome to the *Gopherbot* terminal connector. Since no configuration
was detected, you're connected to 'floyd', the default robot.
general: If you've started the robot by mistake, just hit ctrl-D to exit and try
'gopherbot --help'; otherwise feel free to play around with the default robot -
you can start by typing 'help'. If you'd like to start configuring a new robot,
type: ';setup'.
c:general/u:alice -&gt; ;setup
...
</code></pre>
<h1><a class="header" href="#deploying-and-running-your-robot" id="deploying-and-running-your-robot">Deploying and Running Your Robot</a></h1>
<p><strong>Gopherbot</strong> is very flexible about being able to bootstrap and run in a variety of environments. This chapter discusses the three primary ways you'll run your robot:</p>
<ul>
<li>It's helpful if you have access to a Linux workstation, VM, or container where you can bootstrap your robot and use <a href="deploy/CLI.html">CLI commands</a>
<ul>
<li>Microsoft's free <a href="https://code.visualstudio.com/">VisualStudio Code</a> has a remote extension that will allow you to edit files directly in a container, and the robot's adminstrator <strong>save</strong> command can push updates to the robot's git repository</li>
<li>If you robot is stored in a public <a href="https://github.com">Github</a> repository, you can use <a href="https://gitpod.io">Gitpod</a> to work with your robot at the CLI</li>
</ul>
</li>
<li>The <code>resources/</code> directory contains a template <code>robot.service</code> that can be used to run your robot on a Linux host <a href="deploy/systemd.html">using Systemd</a></li>
<li>Using <a href="https://podman.io">Podman</a>, <a href="https://docker.com">Docker</a>, <a href="https://kubernetes.io">Kubernetes</a>, or any number of other container-centric environments, you can bootstrap and run your robot <a href="deploy/Container.html">in a Container</a></li>
</ul>
<h2><a class="header" href="#the-env-file" id="the-env-file">The <code>.env</code> file</a></h2>
<p>Regardless of your running environment, you'll need a copy of your robot's <code>.env</code> file generated when you configured your robot. If <code>GOPHER_PROTOCOL</code> is set, you might want it commented out so you can run your robot with the <strong>terminal</strong> connector, instead of having it connect to your team chat. For <strong>Clu</strong>, the <code>.env</code> looks like this:</p>
<pre><code>GOPHER_ENCRYPTION_KEY=&lt;redacted&gt;
#GOPHER_PROTOCOL=slack
GOPHER_CUSTOM_REPOSITORY=git@github.com:parsley42/clu-gopherbot.git
GOPHER_DEPLOY_KEY=-----BEGIN_OPENSSH_PRIVATE_KEY-----:&lt;much junk removed&gt;:-----END_OPENSSH_PRIVATE_KEY-----:
</code></pre>
<h1><a class="header" href="#cli-operation" id="cli-operation">CLI Operation</a></h1>
<p>The <code>gopherbot</code> binary can run as both a daemon and a command-line interface, mainly used for generating encrypted secrets. This section discusses running your robot from the command-line.</p>
<h2><a class="header" href="#setting-up-for-cli-operation" id="setting-up-for-cli-operation">Setting up For CLI Operation</a></h2>
<p>The next sections describe several methods of running the <strong>Gopherbot</strong> CLI. Be sure <code>GOPHER_PROTOCOL</code> is commented out in your <code>.env</code> file, to prevent your robot from connecting to your team chat.</p>
<h1><a class="header" href="#local-install" id="local-install">Local Install</a></h1>
<p>If you've <a href="deploy/../install/ManualInstall.html">installed Gopherbot</a> on a Linux host, you can just create an empty directory, add your <code>.env</code> file, and start <strong>gopherbot</strong> in terminal mode - letting the <strong>bootstrap</strong> plugin retrieve the rest of your robot:</p>
<pre><code>[parse@hakuin ~]$ mkdir clu
[parse@hakuin ~]$ cd clu/
[parse@hakuin clu]$ vim .env
[parse@hakuin clu]$ ln -s /opt/gopherbot/gopherbot .
[parse@hakuin clu]$ ./gopherbot 
2020/02/20 14:14:20 Debug: Checking os.Stat for dir 'custom' from wd '': stat custom: no such file or directory
2020/02/20 14:14:20 Debug: Checking os.Stat for dir 'conf' from wd '': stat conf: no such file or directory
2020/02/20 14:14:20 Initialized logging ...
...
2020/02/20 14:14:21 Info: Robot is initialized and running
2020/02/20 14:14:21 Info: Creating bootstrap pipeline for git@github.com:parsley42/clu-gopherbot.git
2020/02/20 14:14:21 Warning: /home/parse/clu/custom/git/config not found, git push will fail
2020/02/20 14:14:21 Info: ssh-init starting in bootstrap mode
2020/02/20 14:14:21 Warning: Output from stderr of external command '/home/gopherbot/tasks/ssh-init.sh': Identity added: (stdin) (parse@hakuin.localdomain)
2020/02/20 14:14:22 Warning: Output from stderr of external command '/home/gopherbot/tasks/git-clone.sh': Cloning into '.'...
2020/02/20 14:14:22 Warning: Repository pipeline not found in job  (wd: /home/parse/clu/custom, repo: not set), ignoring
2020/02/20 14:14:22 Info: Restart triggered in pipeline 'bootstrap' with 0 pipelines running (including this one)
2020/02/20 14:14:22 Info: Stop called with 1 pipelines running
2020/02/20 14:14:22 Info: Restarting...
2020/02/20 14:14:22 Info: Stopping signal handler
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
clu-jobs: Starting restore of robot state...
OUT: Agent pid 11337
ERR: Identity added: /home/parse/clu/custom/ssh/manage_key (parse@hakuin.localdomain)
ERR: Cloning into '.'...
ERR: Warning: Permanently added the RSA host key for IP address '192.30.253.112' to the list of known hosts.
clu-jobs: Restore finished
OUT: unset SSH_AUTH_SOCK;
OUT: unset SSH_AGENT_PID;
OUT: echo Agent pid 11337 killed;
c:general/u:alice -&gt; &lt;ctrl-d&gt;
general: @alice Adios
Terminal connector finished
[parse@hakuin clu]$ gopherbot list
pythondemo:memory
links:links
lists:listmap
...
</code></pre>
<h1><a class="header" href="#container-operation" id="container-operation">Container Operation</a></h1>
<p>The next best option to a local install is running the CLI in a container; just drop your robot's <code>.env</code> file in a directory and run the one of the <a href="https://hub.docker.com/r/lnxjedi/gopherbot">stock images</a>, overriding the entrypoint. Using <code>podman</code> as an example:</p>
<pre><code>[parse@hakuin ~]$ mkdir clu
[parse@hakuin ~]$ cd clu/
[parse@hakuin clu]$ vim .env
[parse@hakuin clu]$ podman run -it --entrypoint /bin/bash --env-file .env lnxjedi/gopherbot:latest
daemon@af2a1924e1ff:~$ gopherbot
2020/02/20 19:23:32 Debug: Checking os.Stat for dir 'custom' from wd '': stat custom: no such file or directory
2020/02/20 19:23:32 Debug: Checking os.Stat for dir 'conf' from wd '': stat conf: no such file or directory
2020/02/20 19:23:32 Initialized logging ...
...
2020/02/20 19:26:29 Info: Robot is initialized and running
2020/02/20 19:26:29 Info: Creating bootstrap pipeline for git@github.com:parsley42/clu-gopherbot.git
2020/02/20 19:26:29 Warning: /home/custom/git/config not found, git push will fail
2020/02/20 19:26:29 Info: ssh-init starting in bootstrap mode
2020/02/20 19:26:29 Warning: Output from stderr of external command '/opt/gopherbot/tasks/ssh-init.sh': Identity added: (stdin) (parse@hakuin.localdomain)
2020/02/20 19:26:30 Warning: Output from stderr of external command '/opt/gopherbot/tasks/git-clone.sh': Cloning into '.'...
2020/02/20 19:26:30 Warning: Repository pipeline not found in job  (wd: /home/custom, repo: not set), ignoring
2020/02/20 19:26:30 Info: Restart triggered in pipeline 'bootstrap' with 0 pipelines running (including this one)
2020/02/20 19:26:30 Info: Stop called with 1 pipelines running
2020/02/20 19:26:30 Info: Restarting...
2020/02/20 19:26:30 Info: Stopping signal handler
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
OUT: GOPHER_PROTOCOL is terminal
clu-jobs: Starting restore of robot state...
OUT: Agent pid 440
ERR: Identity added: /home/custom/ssh/manage_key (parse@hakuin.localdomain)
ERR: Cloning into '.'...
clu-jobs: Restore finished
OUT: unset SSH_AUTH_SOCK;
OUT: unset SSH_AGENT_PID;
OUT: echo Agent pid 440 killed;
c:general/u:alice -&gt; &lt;ctrl-d&gt;
general: @alice Sayonara!
Terminal connector finished
daemon@af2a1924e1ff:~$ gopherbot list
pythondemo:memory
links:links
lists:listmap
...
...
</code></pre>
<h1><a class="header" href="#using-gitpod" id="using-gitpod">Using Gitpod</a></h1>
<p><a href="https://gitpod.io">Gitpod</a> is a pretty good way to work with your robot's CLI, with the caveat that your robot needs to be stored in a public repository to use the free service. The standard robot includes a <code>.gitpod.yml</code> file, so if you've already signed up for <strong>Gitpod</strong> you can just visit: https://gitpod.io/#https://github.com/&lt;org&gt;/&lt;robot-repo&gt;, or click the <strong>Gitpod</strong> button if you've installed the <a href="https://www.gitpod.io/docs/browser-extension">browser extension</a>.</p>
<p>When your workspace opens, you can use the <code>File</code> menu to create a new <code>.env</code> file directly in the <code>/workspace</code> folder. Once you've pasted in the contents and saved the file, just start the robot in the lower terminal pane:</p>
<pre><code>gitpod /workspace $ gopherbot 
2020/02/20 19:52:01 Debug: Checking os.Stat for dir 'custom' from wd '': stat custom: no such file or directory
2020/02/20 19:52:01 Debug: Checking os.Stat for dir 'conf' from wd '': stat conf: no such file or directory
2020/02/20 19:52:01 Initialized logging ...
...
2020/02/20 19:52:02 Info: Robot is initialized and running
2020/02/20 19:52:02 Info: Creating bootstrap pipeline for git@github.com:parsley42/clu-gopherbot.git
2020/02/20 19:52:02 Warning: /workspace/custom/git/config not found, git push will fail
2020/02/20 19:52:02 Info: ssh-init starting in bootstrap mode
2020/02/20 19:52:02 Warning: Output from stderr of external command '/opt/gopherbot/tasks/ssh-init.sh': Identity added: (stdin) (parse@hakuin.localdomain)
2020/02/20 19:52:03 Warning: Output from stderr of external command '/opt/gopherbot/tasks/git-clone.sh': Cloning into '.'...
2020/02/20 19:52:03 Warning: Repository pipeline not found in job  (wd: /workspace/custom, repo: not set), ignoring
2020/02/20 19:52:03 Info: Restart triggered in pipeline 'bootstrap' with 0 pipelines running (including this one)
2020/02/20 19:52:03 Info: Stop called with 1 pipelines running
2020/02/20 19:52:03 Info: Restarting...
2020/02/20 19:52:03 Info: Stopping signal handler
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
OUT: GOPHER_PROTOCOL is terminal
clu-jobs: Starting restore of robot state...
OUT: Agent pid 1764
ERR: Identity added: /workspace/custom/ssh/manage_key (parse@hakuin.localdomain)
ERR: Cloning into '.'...
clu-jobs: Restore finished
OUT: unset SSH_AUTH_SOCK;
OUT: unset SSH_AGENT_PID;
OUT: echo Agent pid 1764 killed;
c:general/u:alice -&gt; &lt;ctrl-d&gt;
general: @alice Later gator!
Terminal connector finished
gitpod /workspace $ gopherbot list
links:links
pythondemo:memory
lists:listmap
...
</code></pre>
<h1><a class="header" href="#encrypting-secrets" id="encrypting-secrets">Encrypting Secrets</a></h1>
<p>Once you've set up CLI access, you can use the <code>gopherbot</code> in CLI mode to encrypt various secrets:</p>
<pre><code class="language-shell">gitpod /workspace $ gopherbot encrypt foobarbaz
UK+T6/HocaR9AAD8Ty2giHdNR3r03pbffpah/rk+MZumPK4Y3A==
</code></pre>
<h1><a class="header" href="#running-with-systemd" id="running-with-systemd">Running with Systemd</a></h1>
<p>One way of running your robot is to use a <strong>systemd</strong> unit file on a systemd-managed Linux host:</p>
<ul>
<li>Copy <code>resources/robot.service</code> to <code>/etc/systemd/system/&lt;botname&gt;.service</code> and edit with values for your system; you'll need to create a local user, and a directory for your robot that the user can write to</li>
<li>Reload <code>systemd</code> with <code>systemctl daemon-reload</code></li>
<li>Enable the service with <code>systemctl enable &lt;botname&gt;</code></li>
<li>Place your robot's <code>.env</code> in the robot's home directory, mode <code>0400</code>, owned by the robot user; you can leave <code>GOPHER_PROTOCOL</code> commented out, since the value should be set in the <code>&lt;botname&gt;.service</code> file</li>
<li>Start the service: <code>systemctl start &lt;botname&gt;</code></li>
</ul>
<p>That's it! Your robot should start and connect to your team chat.</p>
<h1><a class="header" href="#running-in-a-container" id="running-in-a-container">Running in a Container</a></h1>
<p>A major goal for <strong>Gopherbot</strong> v2 was container-native operation, and the ability to run your robot with all it's functionality and state/context, without requiring a persistent volume mount or a custom image with your robot baked-in. You can launch your robot using any of the <a href="https://hub.docker.com/r/lnxjedi/gopherbot">stock images</a>; you should only need to create a custom image if your robot requires specific extra tools or libraries to do it's work, such as e.g. an ldap client or specific python module.</p>
<p>This section doesn't delve in to the specifics of running your robot in any particular container environment. Whether your robot runs as a persistent container on a Docker host, or as a managed container in a Kubernetes or Openshift cluster - or elsewhere - the same principles apply. If you're planning on deploying in a container, it is presumed that you're already running other containerized workloads, and can provide the requirements by common means for your container environment.</p>
<p>The contents of your robot's <code>.env</code> file are all that's needed - the built-in <strong>bootstrap</strong> plugin will use your robot's <code>deploy_key</code> key to clone it's <code>GOPHER_CUSTOM_REPOSITORY</code> configuration repository, then use the <code>GOPHER_ENCRYPTION_KEY</code> to decrypt the <code>manage_key</code> ssh private key to restore file-backed memories if you use the default <code>file</code> brain for the standard robot.</p>
<p>You can find example <code>docker</code> commands and comments regarding usage in <code>resources/docker/Makefile</code>.</p>
<h2><a class="header" href="#container-considerations" id="container-considerations">Container Considerations</a></h2>
<h3><a class="header" href="#backing-up-state-and-memories" id="backing-up-state-and-memories">Backing up State and Memories</a></h3>
<p>The standard robot includes a commented-out definition for scheduling the <code>backup</code> job in the stock <code>robot.yaml</code>. You should uncomment this and set a relatively frequent schedule for backups. The underlying job uses <code>git status --porcelain</code> to determine if a backup is needed, so there's little overhead in the case where memories don't change frequently. Since new memories tend to come in batches - for instance, adding bookmarks with the links plugin - an hourly schedule probably strikes a good balance between keeping the <code>robot-state</code> branch updated while not creating too many superfluous commits.</p>
<p>The <strong>bootstrap</strong> plugin will trigger a restore during start-up, so launching your robot into a new, empty container should restore it's state and memories automatically. Take care that you don't run multiple instances of your robot; not only would this run the risk of corrupting state, but this can produce strange behavior in your team chat.</p>
<h3><a class="header" href="#providing-environment-variables" id="providing-environment-variables">Providing Environment Variables</a></h3>
<p>When launching your robot in a container, you'll need to provide the environment variables defined in the robot's <code>.env</code> file. There are two primary ways of accomplishing this:</p>
<ul>
<li>Both <code>docker</code> and <code>podman</code> allow you to set environment variables with a <code>--env-file .env</code> argument</li>
<li>Container orchestration environments or e.g. <code>docker-compose</code> provide other means of providing these values; take care that the value for <code>GOPHER_ENCRYPTION_KEY</code> doesn't get committed to a repository</li>
</ul>
<h3><a class="header" href="#setting-the-gopher_protocol-environment-variable" id="setting-the-gopher_protocol-environment-variable">Setting the <code>GOPHER_PROTOCOL</code> Environment Variable</a></h3>
<p>When starting <code>gopherbot</code> at the CLI, or using systemd, the value for <code>GOPHER_PROTOCOL</code> should be commented out in the <code>.env</code>; this value is required for launching in a container so that your robot will start and connect to your team chat.</p>
<h1><a class="header" href="#configuring-gopherbot" id="configuring-gopherbot">Configuring Gopherbot</a></h1>
<p><strong>Gopherbot</strong> has very powerful and flexible configuration capabilities based on <em>yaml</em> templates. The core concept is simple; <strong>Gopherbot</strong> ships with default configuration in the <code>conf/</code> directory of the installation archive, and individual robots can modify and override the default configuration with environment variables and custom configuration files. This chapter examines the configuration system in detail.</p>
<h1><a class="header" href="#gopherbot-environment-variables" id="gopherbot-environment-variables">Gopherbot Environment Variables</a></h1>
<p><strong>Gopherbot</strong> makes extensive use of environment variables, both for configuring the robot and plugins, and for providing parameters to external scripts. This article describes the various environment variables and their use; for the environment applicable to a given running task, see <a href="pipelines/TaskEnvironment.html">per-task environment</a>.</p>
<h2><a class="header" href="#robot-execution-environment" id="robot-execution-environment">Robot Execution Environment</a></h2>
<p>Certain environment variables can be supplied to the running <strong>Gopherbot</strong> process to configure and/or bootstrap your robot. These environment variables can be set by:</p>
<ul>
<li><code>systemd</code> - Not recommded; while systemd can provide environment variables to your robot, it's insecure and will allow local users on the system to view the values</li>
<li><code>$GOPHER_HOME/private/environment</code> - a slightly better option, normally used for devel robots with <code>fetch-robot.sh</code>, where <code>private</code> is a private repository with the single file <code>environment</code></li>
<li><code>docker</code> or <code>docker-compose</code> - these and other container environments provide more secure means of providing environment variables to containers</li>
<li><code>$GOPHER_HOME/.env</code> - the most secure means is by creating a <code>.env</code> in <code>$GOPHER_HOME</code>, outside of any git repository, mode <code>0600</code></li>
</ul>
<p>The last two options are recommended for production deployments of a <strong>Gopherbot</strong> robot.</p>
<h3><a class="header" href="#start-up-environment" id="start-up-environment">Start-up Environment</a></h3>
<p>The following values can be provided to your robot on start-up:</p>
<ul>
<li><code>GOPHER_ENCRYPTION_KEY</code> - 32+ character encryption key used for decrypting the <code>binary-encrypted-key</code></li>
<li><code>GOPHER_CUSTOM_REPOSITORY</code> - clone URL for the robot's custom configuration, used in bootstrapping</li>
<li><code>GOPHER_CUSTOM_BRANCH</code> - branch to use if other than <code>master</code></li>
<li><code>GOPHER_LOGFILE</code> - where to write out a log file</li>
<li><code>GOPHER_CONFIGDIR</code> - absolute or relative path to configuration directory</li>
<li><code>GOPHER_DEPLOY_KEY</code> - ssh deploy key for cloning the custom repository</li>
</ul>
<p>For the optional <code>state</code> and <code>private</code> repositories, the included jobs will use the <code>GOPHER_CUSTOM_REPOSITORY</code> value with <code>s/gopherbot/state/</code> and <code>s/gopherbot/private/</code> (same branch). If desired, the values can also be supplied:</p>
<ul>
<li><code>GOPHER_STATE_REPOSITORY</code> - repository holding state, normally just a file-backed brain, defaults to <code>$GOPHER_CUSTOM_REPOSITORY</code> and <code>robot-state</code> branch</li>
<li><code>GOPHER_STATE_BRANCH</code> - if <code>GOPHER_STATE_REPOSITORY</code> is set, this defaults to <code>master</code>, otherwise <code>robot-state</code></li>
<li><code>GOPHER_PRIVATE_REPOSITORY</code> - non-public repository with <code>environment</code>, for dev only</li>
<li><code>GOPHER_PRIVATE_BRANCH</code> - branch to use if other than <code>master</code></li>
</ul>
<h3><a class="header" href="#configuration-environment-variables" id="configuration-environment-variables">Configuration Environment Variables</a></h3>
<p><strong>Gopherbot</strong> normally takes almost all of it's configuration from the collection of <code>*.yaml</code> files in the custom configuration directory, but for easy flexibility, a collection of environment variables are referenced in the default configuration. These are some of the values that are expanded; the actual configuration files are the definitive reference.</p>
<ul>
<li><code>GOPHER_PROTOCOL</code> - used to select a non-default protocol (e.g. &quot;terminal&quot;)</li>
<li><code>GOPHER_LOGLEVEL</code> - error, warn, info, debug, trace</li>
<li><code>GOPHER_BOTNAME</code> - the name the robot will answer to, e.g. &quot;floyd&quot;</li>
<li><code>GOPHER_ALIAS</code> - the one-character alias for the robot, e.g. &quot;;&quot;</li>
<li><code>GOPHER_BOTMAIL</code> - the robot's email address</li>
<li><code>GOPHER_BOTFULLNAME</code> - the robot's full name</li>
<li><code>GOPHER_HISTORYDIR</code> - directory for storing file-based historical job logs</li>
<li><code>GOPHER_WORKSPACE</code> - workspace directory where e.g. build jobs clone and run</li>
<li><code>GOPHER_BRAIN</code> - non-default brain provider to use</li>
<li><code>GOPHER_STATEDIR</code> - default dir for storing state, normally just the brain</li>
<li><code>GOPHER_BRAIN_DIRECTORY</code> - directory where file-based memories are stored, overrides above</li>
<li><code>GOPHER_JOBCHANNEL</code> - where jobs run by default if not otherwise specified</li>
<li><code>GOPHER_TIMEZONE</code> - UNIX tz, e.g. &quot;America/New_York&quot; (default)</li>
</ul>
<h2><a class="header" href="#external-script-environment" id="external-script-environment">External Script Environment</a></h2>
<p><strong>Gopherbot</strong> always scrubs the environment when executing tasks, so environment variables set on execution are not automatically passed to child processes. The only environment variables that are passed through from original execution are:</p>
<ul>
<li><code>HOME</code> - this should rarely be used; for portable robots, use <code>GOPHER_HOME</code>, instead</li>
<li><code>HOSTNAME</code></li>
<li><code>LANG</code></li>
<li><code>PATH</code> - this should be used with care since it can make your robot less portable</li>
<li><code>USER</code></li>
</ul>
<p>In addition to the above passed-through environment vars, <strong>Gopherbot</strong> supplies the following environment variables to external scripts:</p>
<ul>
<li><code>GOPHER_INSTALLDIR</code> - absolute path to the gopherbot install, normally <code>/opt/gopherbot</code></li>
</ul>
<h2><a class="header" href="#automatic-environment-variables" id="automatic-environment-variables">Automatic Environment Variables</a></h2>
<p>During startup, <strong>Gopherbot</strong> will examine it's environment and potentially set values for a few environment variables to support the bootstrap and setup plugins, and simplify common operations.</p>
<p>First, <strong>Gopherbot</strong> will check for custom configuration or the presence of a <code>GOPHER_CUSTOM_REPOSITORY</code> environment variable. In the absence of either, the following will be automatically set:</p>
<ul>
<li><code>GOPHER_UNCONFIGURED</code> - set true</li>
<li><code>GOPHER_LOGFILE</code> - set to &quot;robot.log&quot; if not already set</li>
<li><code>GOPHER_PROTOCOL</code> - set to &quot;terminal&quot; so the default robot will start</li>
</ul>
<p>If no custom configuration is present but <code>GOPHER_CUSTOM_REPOSITORY</code> is set:</p>
<ul>
<li><code>GOPHER_PROTOCOL</code> - set to &quot;nullconn&quot;, the null connector, to allow the bootstrap plugin to bootstrap your robot</li>
</ul>
<p>If the robot is configured but <code>GOPHER_PROTOCOL</code> isn't set:</p>
<ul>
<li><code>GOPHER_PROTOCOL</code> - set to &quot;terminal&quot; for local operations</li>
<li><code>GOPHER_LOGFILE</code> - set to &quot;robot.log&quot; if not already set</li>
</ul>
<p>Finally, if encryption is initialized on start-up, <code>GOPHER_ENCRYPTION_INITIALIZED</code> will be set to <code>true</code>, regardless of whether the robot is configured.</p>
<h2><a class="header" href="#pipeline-environment-variables" id="pipeline-environment-variables">Pipeline Environment Variables</a></h2>
<p>The following environment variable are set for all pipelines, whether started by a plugin or a job:</p>
<ul>
<li><code>GOPHER_CHANNEL</code> - the channel where the plugin/job is providing output</li>
<li><code>GOPHER_USER</code> - the user whose message created the pipeline (if any)</li>
<li><code>GOPHER_PROTOCOL</code> - the name of the protocol in use, e.g. &quot;slack&quot;</li>
<li><code>GOPHER_TASK_NAME</code> - the name of the running task</li>
<li><code>GOPHER_PIPELINE_TYPE</code> - the event type that started the current pipeline, one of:
<ul>
<li><code>plugCommand</code> - direct robot command, not <code>run job ...</code></li>
<li><code>plugMessage</code> - ambient message matched</li>
<li><code>catchAll</code> - catchall plugin ran</li>
<li><code>jobTrigger</code> - triggered by a JobTrigger</li>
<li><code>scheduled</code> - started by a ScheduledTask</li>
<li><code>jobCommand</code> - started from <code>run job ...</code> command</li>
</ul>
</li>
</ul>
<p>The following are also supplied whenever a job is run:</p>
<ul>
<li><code>GOPHER_JOB_NAME</code> - the name of the running job</li>
<li><code>GOPHER_START_CHANNEL</code> - the channel where the job was started</li>
<li><code>GOPHER_REPOSITORY</code> - the extended namespace from <code>repositories.yaml</code>, if any</li>
<li><code>GOPHER_RUN_INDEX</code> - the run number of the job</li>
</ul>
<p>Pipelines and tasks that have <code>Homed: true</code> and/or <code>Privileged: true</code> may also get:</p>
<ul>
<li><code>GOPHER_HOME</code> - absolute path to the startup directory for the robot, relative paths are relative to this directory; unset if <code>cwd</code> can't be determined</li>
<li><code>GOPHER_WORKSPACE</code> - the workspace directory (normally relative to <code>GOPHER_HOME</code>)</li>
<li><code>GOPHER_CONFIGDIR</code> - absolute path to custom configuration directory, normally <code>$GOPHER_HOME/custom</code></li>
</ul>
<h3><a class="header" href="#gopherci-environment-variables" id="gopherci-environment-variables">GopherCI Environment Variables</a></h3>
<p>In addition to the environment variables set by the <strong>Gopherbot</strong> engine, the <code>localbuild</code> GopherCI builder sets the following environment variables that can be used to modify pipelines:</p>
<ul>
<li><code>GOPHERCI_BRANCH</code> - the branch being built (<code>GOPHER_REPOSITORY</code> is set by <code>ExtendNamespace</code>)</li>
<li><code>GOPHERCI_DEPBUILD</code> - set to &quot;true&quot; if the build was triggered by a dependency</li>
<li><code>GOPHERCI_DEPREPO</code> - the updated repository that triggered this build</li>
<li><code>GOPHERCI_DEPBRANCH</code> - the updated branch</li>
</ul>
<h1><a class="header" href="#configuration-file-loading" id="configuration-file-loading">Configuration File Loading</a></h1>
<p><strong>Gopherbot</strong> uses <strong>YAML</strong> for it's configuration files, and Go text templates for expanding the files it reads. Any time <strong>Gopherbot</strong> loads a configuration file, say <code>conf/robot.yaml</code>, it first looks for the file in the installation directory, and loads and expands that file if found. Next it looks for the same file in the custom configuration directory; if found, it loads and expands that file, then recursively merges the two data structures:</p>
<ul>
<li>Map values merge and override</li>
<li>Array values are replaced</li>
</ul>
<p>To illustrate with an example, take the following two excerpts from <code>robot.yaml</code>:</p>
<p>Default from the install archive:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: general
  Channels:
  - random
  - general
  StartUser: alice
</code></pre>
<p>Custom local configuration:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: jobs
  Channels:
  - jobs
  - general
</code></pre>
<p>The resulting configuration would be:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: jobs
  Channels:
  - jobs
  - general
  StartUser: alice
</code></pre>
<h2><a class="header" href="#template-expansion" id="template-expansion">Template Expansion</a></h2>
<p><strong>Gopherbot</strong> uses standard <a href="https://golang.org/pkg/text/template">Go text templates</a> for expanding the configuration files it reads. In addition to the stock syntactic elements, the following functions and methods are available:</p>
<h3><a class="header" href="#the-env-function" id="the-env-function">The <code>env</code> function</a></h3>
<pre><code>{{ env &quot;GOPHER_ALIAS&quot; }}
</code></pre>
<p>This would expand to the value of the <code>GOPHER_ALIAS</code> environment variable.</p>
<h3><a class="header" href="#the-default-function" id="the-default-function">The <code>default</code> function</a></h3>
<pre><code>{{ env &quot;GOPHER_ALIAS&quot; | default &quot;;&quot; }}
</code></pre>
<p>The <code>default</code> function takes two arguments, and returns the first argument if it's length is &gt; 0, the second argument otherwise. The example would expand to the value of the <code>GOPHER_ALIAS</code> environment variable if set, or <code>;</code> otherwise.</p>
<h2><a class="header" href="#the-decrypt-function" id="the-decrypt-function">The <code>decrypt</code> function</a></h2>
<pre><code>ProtocolConfig:
  SlackToken: xoxb-18000000000-470000000000-{{ decrypt &quot;xxxxx&quot; }}
</code></pre>
<p>To make it safe to store secret values in configuration, administrators can send a direct message to the robot requesting encryption, e.g.:</p>
<pre><code>c:(direct)/u:alice -&gt; encrypt MyLousyPassword
(dm:alice): RPzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx+9rf==
</code></pre>
<p>The encrypted value can then be pasted in to the <code>decrypt</code> function. See the section on <em>encryption</em> for more information.</p>
<p><strong>NOTE:</strong> In the example, the common, low-entropy portion of a <em>slack</em> token is left as-is, and only the high-entropy portion of the token is encrypted, to prevent attacks where a portion of the encrypted value is known.</p>
<h2><a class="header" href="#the-include-method" id="the-include-method">The <code>.Include</code> method</a></h2>
<pre><code>{{ .Include &quot;terminal.yaml&quot; }}
</code></pre>
<p><code>.Include</code> is a <em>method</em> on the configuration file object, which is either an install file or a custom file. If the above example is present in the installed <code>conf/robot.yaml</code>, it will include <em>only</em> the installed <code>conf/terminal.yaml</code>, if present, and ignore that file if it's also present in the custom directory.</p>
<p>Note that <code>.Include</code>'d files are also expanded as templates in the same manner.</p>
<h1><a class="header" href="#job-and-plugin-configuration" id="job-and-plugin-configuration">Job and Plugin Configuration</a></h1>
<h1><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h1>
<p>TODO: docs on using CLI commands to dump yaml.</p>
<h1><a class="header" href="#administering-your-robot" id="administering-your-robot">Administering Your Robot</a></h1>
<h1><a class="header" href="#administrator-commands" id="administrator-commands">Administrator Commands</a></h1>
<h1><a class="header" href="#command-line-use" id="command-line-use">Command-Line Use</a></h1>
<h1><a class="header" href="#logging" id="logging">Logging</a></h1>
<h2><a class="header" href="#api-for-plugins-jobs-and-tasks" id="api-for-plugins-jobs-and-tasks">API for Plugins, Jobs and Tasks</a></h2>
<p><strong>Gopherbot</strong> provides an object-oriented API for writing your own command plugins, jobs and tasks. With the exception of the <code>bash</code> library, API calls are accessed from methods on a <strong>robot</strong> object. The following sections detail the usage of the various methods.</p>
<p>Gopherbot's functionality can be easily extended by writing plugins in one of several different languages. A single plugin can provide:</p>
<ul>
<li>One or more new commands the robot will understand</li>
<li>Elevation logic for providing extra assurance of user identity</li>
<li>Authorization logic for determining a user's rights to issue various commands</li>
</ul>
<p>This article deals mainly with writing plugins in one of the scripting languages supported by Gopherbot, the most popular means for writing new command plugins. For writing native compiled-in plugins in Go, see <code>gopherbot/main.go</code> and the sample plugins in <code>goplugins/</code>. API documentation for Robot methods is available at:</p>
<p>https://godoc.org/github.com/lnxjedi/gopherbot/bot#Robot</p>
<p>Note that the script plugin API is implemented on top of the native Go API, so that document may also be of use for scripting plugin authors. The file <code>bot/http.go</code>, and the scripting libraries in <code>lib/</code> will illuminate the mapping from the script APIs to the native Go API.</p>
<h1><a class="header" href="#table-of-contents" id="table-of-contents">Table of Contents</a></h1>
<ul>
<li><a href="api/Languages.html#plugin-loading-and-precedence">Plugin Loading and Precedence</a></li>
<li><a href="api/Languages.html#default-configuration">Default Configuration</a></li>
<li><a href="api/Languages.html#calling-convention">Calling Convention</a>
<ul>
<li><a href="api/Languages.html#environment-variables">Environment Variables</a></li>
<li><a href="api/Languages.html#reserved-commands">Reserved Commands</a></li>
</ul>
</li>
<li><a href="api/Languages.html#plugin-types-and-calling-events">Plugin Types and Calling Events</a>
<ul>
<li><a href="api/Languages.html#command-plugins">Command Plugins</a></li>
<li><a href="api/Languages.html#authorization-plugins">Authorization Plugins</a></li>
<li><a href="api/Languages.html#elevation-plugins">Elevation Plugins</a></li>
</ul>
</li>
<li><a href="api/Languages.html#using-the-terminal-connector">Using the Terminal Connector</a></li>
<li><a href="api/Languages.html#plugin-debugging">Plugin Debugging</a>
<ul>
<li><a href="api/Languages.html#debug-plugin-command">Debug Plugin Command</a></li>
<li><a href="api/Languages.html#dump-plugin-command">Dump Plugin Command</a></li>
</ul>
</li>
<li><a href="api/Languages.html#getting-started">Getting Started</a>
<ul>
<li><a href="api/Languages.html#starting-from-a-sample-plugin">Starting from a Sample Plugin</a></li>
<li><a href="api/Languages.html#using-boilerplate-code">Using Boilerplate Code</a>
<ul>
<li><a href="api/Languages.html#bash-boilerplate">Bash Boilerplate</a></li>
<li><a href="api/Languages.html#powershell-boilerplate">PowerShell Boilerplate</a></li>
<li><a href="api/Languages.html#python-boilerplate">Python Boilerplate</a></li>
<li><a href="api/Languages.html#ruby-boilerplate">Ruby Boilerplate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="api/Languages.html#the-plugin-api">The Plugin API</a></li>
</ul>
<h1><a class="header" href="#plugin-loading-and-precedence" id="plugin-loading-and-precedence">Plugin Loading and Precedence</a></h1>
<p>Gopherbot ships with a number of external script plugins in the <code>install</code> directory. These can be overridden by placing a plugin with the same filename in the optional configuration directory.</p>
<h1><a class="header" href="#default-configuration" id="default-configuration">Default Configuration</a></h1>
<p>Plugin configuration is fully documented in the <a href="api/Configuration.html">configuration</a> article; you should be familiar with that document before beginning to write your own plugins.</p>
<p>On start-up and during a reload, the robot will run each external script plugin with an argument of <code>configure</code>. The plugin should respond by writing the plugin default configuration to standard out and exiting with exit code 0. When responding to <code>configure</code>, the plugin shouldn't initialize a robot object or make any API calls, as <code>configure</code> is called without setting robot environment variables.</p>
<h1><a class="header" href="#calling-convention" id="calling-convention">Calling Convention</a></h1>
<p>The robot calls external plugins by creating a goroutine and exec'ing the external script with a set of environment variables. The external script uses the appropriate library for the scripting language to create a robot object from the environment. The script then examines it's command-line arguments to determine the type of action to take (normally a command followed by arguments to the command), and uses the library to make JSON-over-http calls for executing and returning results from methods. Depending on how the plugin is used, different kinds of events can cause external plugins to be called with a variety of commands and arguments. The most common means of calling an external plugin is for one of it's commands to be matched, or by matching a pattern in an ambient message (one not specifically directed to the robot).</p>
<p>There are two sources of information for an external plugin being called:</p>
<ul>
<li>Environment Variables - these should generally only be referenced by the scripting library</li>
<li>Command Line Arguments - these should be used by the plugin to determine what to do</li>
</ul>
<h2><a class="header" href="#environment-variables" id="environment-variables">Environment Variables</a></h2>
<p>Gopherbot sets two primary environment variables of use to the plugin developer:</p>
<ul>
<li>GOPHER_CONFIGDIR - the directory where Gopherbot looks for it's configuration</li>
<li>GOPHER_INSTALLDIR - the directory where the Gopherbot executable resides</li>
</ul>
<p>In addition, the following two environment variables are set for every script plugin:</p>
<ul>
<li>GOPHER_USER - the username of the user who spoke to the robot</li>
<li>GOPHER_CHANNEL - the channel the user spoke in (empty string indicates a direct message)</li>
</ul>
<h2><a class="header" href="#reserved-commands" id="reserved-commands">Reserved Commands</a></h2>
<p>The first argument to a plugin script is the <strong>command</strong>. In addition to the <code>configure</code> command, which instructs a plugin to dump it's default configuration to standard out, the following commands are reserved:</p>
<ul>
<li><code>init</code> - After starting the connector and on reload, the robot will call external plugins with a command argument of <code>init</code>. Since all environment variables for the robot are set at that point, it would be possible to e.g. save a robot data structure that could be loaded and used in a cron job.</li>
<li><code>authorize</code> - The plugin should check authorization for the user and return <code>Success</code> or <code>Fail</code></li>
<li><code>elevate</code> - The plugin should perform additional authentication for the user and return <code>Success</code> or <code>Fail</code></li>
<li><code>event</code> - This command is reserved for future use with e.g. user presence change &amp; channel join/leave events</li>
<li><code>catchall</code> - Plugins with <code>CatchAll: true</code> will be called for commands directed at the robot that don't match a command plugin. Normally these are handled by the compiled-in <code>help</code> plugin, but administrators could override that setting and provide their own plugin with <code>CatchAll: true</code>. Note that having multiple such plugins is probably a bad idea.</li>
</ul>
<h1><a class="header" href="#plugin-types-and-calling-events" id="plugin-types-and-calling-events">Plugin Types and Calling Events</a></h1>
<p>There are (currently) three different kinds of external plugin:</p>
<ul>
<li>Command / Message Plugins - these are called by the robot in respond to messages the user sends</li>
<li>Authorization Plugins - these plugins encapsulate the logic for authorizing specific users to use specific commands, and are called by the robot during authorization processing</li>
<li>Elevation Plugins - these plugins perform some variety of multi-factor authentication for higher assurance of user identity, and are called by the robot during elevation processing</li>
</ul>
<h2><a class="header" href="#command-plugins" id="command-plugins">Command Plugins</a></h2>
<p>A command plugin's configuration specifies <code>CommandMatchers</code> and <code>MessageMatchers</code> that associate regular expressions with plugin commands:</p>
<pre><code class="language-yaml">MessageMatchers:
- Command: help
  Regex: '^(?i:help)$'
CommandMatchers:
- Regex: (?i:remember ([-\w .,!?:\/]+))
  Command: remember
  Contexts: [ &quot;item&quot; ]
</code></pre>
<p>Whenever a <code>CommandMatcher</code> regex matches a command given to the robot, or a <code>MessageMatcher</code> matches an ambient message, the robot calls the plugin script with the first argument being the matched <code>Command</code>, and subsequent arguments corresponding to the regex capture groups (which may in some cases be an empty string). Command plugins should normally exit with status 0 (bot.Normal), or non-zero for unusual error conditions that may require an administrator to investigate. The robot will notify the user whenever a command plugin exits non-zero, or when it emits output to STDERR.</p>
<h2><a class="header" href="#authorization-plugins" id="authorization-plugins">Authorization Plugins</a></h2>
<p>To separate command logic from user authorization logic, Gopherbot supports the concept of an <strong>authorization plugin</strong>. The main <code>robot.yaml</code> can define a specific plugin as the <code>DefaultAuthorizer</code>, and individual plugins can be configured to override this value by specifying their own <code>Authorizer</code> plugin. If a plugin lists any commands in it's <code>AuthorizedCommands</code> config item, or specifies <code>AuthorizeAllCommands: true</code>, then the robot will call the authorizer plugin with a command of <code>authorize</code>, followed by the following arguments:</p>
<ul>
<li>The name of the plugin for which authorization is being requested</li>
<li>The optional value of <code>AuthRequire</code>, which may be interpreted as a group or role</li>
<li>The plugin command being called followed by any arguments passed to the command</li>
</ul>
<p>Based on these values and the <code>User</code> and <code>Channel</code> values from the robot, the authorization plugin should evaluate whether a user/plugin is authorized for the given command and exit with one of:</p>
<ul>
<li>bot.Succeed (1) - authorized</li>
<li>bot.Fail (2) - not authorized</li>
<li>bot.MechanismFail (3) - a technical issue prevented the robot from determining authorization</li>
</ul>
<p>Note that exiting with <code>bot.Normal</code> (0) or other values will result in an error and failed authentication.</p>
<p>Additionally, authorization plugins may provide extra feedback to the user on <code>Fail</code> or <code>MechanismFail</code> so they can have the issue addressed, e.g. &quot;Authorization failed: user not a member of group 'foo'&quot;. In some cases, however, authorization plugins may not have a full Gopherbot API library; they could be written in C, and thus not be able to interact with the user.</p>
<h2><a class="header" href="#elevation-plugins" id="elevation-plugins">Elevation Plugins</a></h2>
<p>Elevation plugins provide the means to request additional authentication from the user for commands where higher assurance of identity is desired. The main <code>robot.yaml</code> can specify an elevation plugin as the <code>DefaultElevator</code>, which can be overridden by a given plugin specifying an <code>Elevator</code>. When the plugin lists commands as <code>ElevatedCommands</code> or <code>ElevateImmediateCommands</code>, the robot will call the appropriate elevator plugin with a command of <code>elevate</code> and a first argument of <code>true</code> or <code>false</code> for <code>immediate</code>. The elevator plugin should interpret <code>immediate == true</code> to mean MFA is required every time; when <code>immediate != true</code>, successful elevation may persist for a configured timeout period.</p>
<p>Based on the result of the elevation determination, the plugin should have an exit status one of:</p>
<ul>
<li>bot.Succeed (1) - elevation succeeded</li>
<li>bot.Fail (2) - elevation failed</li>
<li>bot.MechanismFail (3) - a technical issue prevented the robot from processing the elevation request</li>
</ul>
<p>Note that exiting with <code>bot.Normal</code> (0) or other value will result in an error being logged and elevation failing.</p>
<p>Additionally, the elevation plugin may provide extra feedback to the user when elevation isn't successful to indicate the nature of the failure.</p>
<h1><a class="header" href="#using-the-terminal-connector" id="using-the-terminal-connector">Using the Terminal Connector</a></h1>
<p>Interacting with your bot in a chat app might not always be convenient or fast; to simplify
testing and plugin development, <strong>Gopherbot</strong> includes a terminal connector that emulates
a chat service with multiple users and channels, with a sample
configuration in the <code>cfg/term/</code> directory. You'll probably want to copy the directory and modify
it for your own use (mainly configuring the plugins you're developing), but it can be used
by using the <code>-c &lt;configpath&gt;</code> option:</p>
<pre><code>[gopherbot]$ ./gopherbot -c cfg/term/
2018/04/13 18:07:52 Initialized logging ...
2018/04/13 18:07:52 Starting up with config dir: cfg/term/, and install dir: /home/user/go/src/github.com/lnxjedi/gopherbot
2018/04/13 18:07:52 Debug: Loaded installed conf/robot.yaml
2018/04/13 18:07:52 Debug: Loaded configured conf/robot.yaml
Terminal connector running; Use '|C&lt;channel&gt;' to change channel, or '|U&lt;user&gt;' to change user
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; ;ping
general: @bob PONG
c:general/u:bob -&gt; |ualice
Changed current user to: alice
c:general/u:alice -&gt; |crandom
Changed current channel to: random
c:random/u:alice -&gt; ;quit
random: @alice Adios
[gopherbot]$
</code></pre>
<h1><a class="header" href="#plugin-debugging" id="plugin-debugging">Plugin Debugging</a></h1>
<p>The most common problem for plugin authors is the robot does nothing after sending it a message,
or the robot just says <code>Sorry, that didn't match any commands I know, ...</code>.</p>
<p>This can be due to a number of issues:</p>
<ul>
<li>The plugin didn't load because of various configuration problems</li>
<li>The robot isn't in the channel, and doesn't hear the message</li>
<li>The plugin isn't visible because of channel, user, or other restrictions</li>
<li>The user message doesn't match a regex for the plugin</li>
<li>The plugin runs, but does nothing</li>
</ul>
<p>To track down these issues easily, <strong>Gopherbot</strong> has the builtin administrator commands <code>debug plugin</code> and <code>dump plugin</code>. Make sure your username / handle is listed in the
<code>AdminUsers</code> list in <code>robot.yaml</code> for your development environment.</p>
<h2><a class="header" href="#debug-plugin-command" id="debug-plugin-command">Debug Plugin Command</a></h2>
<p><strong>Gopherbot</strong> has a builtin command for plugin debugging that can help quickly pinpoint
most problems. Turning on plugin debugging will initiate a reload, then send debugging
information about a plugin in direct messages. If <code>verbose</code> is enabled, you will get debugging
information for every message you send, or every command sent to the robot by another user.
You can see an example of plugin debugging here with the terminal connector:</p>
<pre><code>[gopherbot]$ ./gopherbot
2018/04/18 15:43:01 Initialized logging ...
2018/04/18 15:43:01 Starting up with config dir: /home/user/.gopherbot, and install dir: /home/user/go/src/github.com/lnxjedi/gopherbot
2018/04/18 15:43:01 Debug: Loaded installed conf/robot.yaml
2018/04/18 15:43:01 Debug: Loaded configured conf/robot.yaml
Terminal connector running; Use '|C&lt;channel&gt;' to change channel, or '|U&lt;user&gt;' to change user
c:general/u:alice -&gt; ;ruby me!
general: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:general/u:alice -&gt; ;help debug
general: Command(s) matching keyword: debug
floyd, debug plugin &lt;pluginname&gt; (verbose) - turn on debugging for the named plugin, optionally verbose

floyd, stop debugging - turn off debugging
c:general/u:alice -&gt; ;debug plugin rubydemo
general: Debugging enabled for rubydemo (verbose: false)
c:general/u:alice -&gt; ;ruby me!
(dm:alice): 2018/04/18 03:43:15 DEBUG rubydemo: plugin is NOT visible to user alice in channel general; channel 'general' is not on the list of allowed channels: random
general: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:general/u:alice -&gt; |crandom
Changed current channel to: random
c:random/u:alice -&gt; ;ruby me to the max!
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: plugin is visible to user alice in channel random
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Checking 7 command matchers against message: &quot;ruby me to the max!&quot;
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:bashecho ([.;!\d\w-, ]+))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:ruby( me)?!?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:listen( to me)?!?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:remember(?: (slowly))? ([-\w .,!?:\/]+))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:recall ?([\d]+)?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:forget ([\d]{1,2}))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:check me)
random: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:random/u:alice -&gt; ;ruby me!
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: plugin is visible to user alice in channel random
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Checking 7 command matchers against message: &quot;ruby me!&quot;
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Not matched: (?i:bashecho ([.;!\d\w-, ]+))
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Matched command regex '(?i:ruby( me)?!?)', command: ruby
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Running plugin with command 'ruby' and arguments: [ me]
random: Sure, Alice!
random: I'll ruby you, but not right now - I'll wait 'til you're least expecting it...
(dm:alice): 2018/04/18 03:43:51 DEBUG rubydemo: Plugin finished with return value: Normal
</code></pre>
<p><strong>NOTE:</strong> If your plugin is disabled with a mysterious <code>File not found</code> error, be sure you've got the
appropriate scripting language installed. If the first line in your plugin is e.g.:</p>
<pre><code>#!/usr/bin/ruby
</code></pre>
<p>... you'll get <code>File not found</code> if <code>/usr/bin/ruby</code> isn't present on the system.</p>
<h2><a class="header" href="#dump-plugin-command" id="dump-plugin-command">Dump Plugin Command</a></h2>
<p>To view a plugin's default or final configuration, you can use the <code>dump plugin</code> command:</p>
<pre><code>c:general/u:alice -&gt; ;help dump
general: Command(s) matching keyword: dump
floyd, dump plugin (default) &lt;plugname&gt; - dump the current or default configuration for the plugin (direct message only)

floyd, dump robot - dump the current configuration for the robot (direct message only)
c:general/u:alice -&gt; |c
Changed current channel to: direct message
c:(direct)/u:alice -&gt; dump plugin rubydemo
(dm:alice): AdminCommands: null
AllChannels: false
AllowDirect: true
AuthRequire: &quot;&quot;
AuthorizeAllCommands: false
AuthorizedCommands: null
Authorizer: &quot;&quot;
CatchAll: false
... (MUCH more)
</code></pre>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<h2><a class="header" href="#starting-from-a-sample-plugin" id="starting-from-a-sample-plugin">Starting from a Sample Plugin</a></h2>
<p>The simplest way for a new plugin author to get started is to:</p>
<ul>
<li>Disable the demo plugin for your chosen scripting language (if enabled) in <code>&lt;config dir&gt;/conf/robot.yaml</code></li>
<li>Copy the demo plugin to <code>&lt;config dir&gt;/plugins/&lt;newname&gt;(.extension)</code></li>
<li>Enable your new plugin in <code>robot.yaml</code> and give it a descriptive <code>Name</code></li>
</ul>
<h2><a class="header" href="#using-boilerplate-code" id="using-boilerplate-code">Using Boilerplate Code</a></h2>
<p>Each supported scripting language has a certain amount of &quot;boilerplate&quot; code required in every command plugin; generally, the boilerplate code is responsible for:</p>
<ul>
<li>Loading the appropriate version of the Gopherbot library from <code>$GOPHER_INSTALLDIR/lib</code></li>
<li>Defining and providing the default config</li>
<li>Instantiating a Robot object with a library call
Normally this is followed by some form of case / switch statement that performs different functions based on the contents of the first argument, a.k.a. the &quot;command&quot;.</li>
</ul>
<h3><a class="header" href="#bash-boilerplate" id="bash-boilerplate">Bash Boilerplate</a></h3>
<pre><code class="language-bash">#!/bin/bash -e

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

COMMAND=$1
shift

configure(){
  cat &lt;&lt;&quot;EOF&quot;
&lt;yaml config document&gt;
EOF
}

case &quot;$COMMAND&quot; in
	&quot;configure&quot;)
		configure
		;;
...
esac
</code></pre>
<p><strong>NOTE:</strong> Bash doesn't have an object-oriented API</p>
<h3><a class="header" href="#python-boilerplate" id="python-boilerplate">Python Boilerplate</a></h3>
<pre><code class="language-python">#!/usr/bin/python3

import os
import sys
sys.path.append(&quot;%s/lib&quot; % os.getenv(&quot;GOPHER_INSTALLDIR&quot;))
from gopherbot_v2 import Robot # use _v1 for python2

bot = Robot()

default_config = '''
&lt;yaml config document&gt;
'''

executable = sys.argv.pop(0)
command = sys.argv.pop(0)

if command == &quot;configure&quot;:
    print default_config
...
</code></pre>
<h3><a class="header" href="#ruby-boilerplate" id="ruby-boilerplate">Ruby Boilerplate</a></h3>
<pre><code class="language-ruby">#!/usr/bin/ruby

# boilerplate
require ENV[&quot;GOPHER_INSTALLDIR&quot;] + '/lib/gopherbot_v1'

bot = Robot.new()

defaultConfig = &lt;&lt;'DEFCONFIG'
&lt;yaml config document&gt;
DEFCONFIG

command = ARGV.shift()

case command
when &quot;configure&quot;
	puts defaultConfig
	exit
...
end
</code></pre>
<h1><a class="header" href="#the-plugin-api" id="the-plugin-api">The Plugin API</a></h1>
<p>Gopherbot has a rich set of methods (functions) for interacting with the robot / user. Here we break down the API into sets of related functions:</p>
<ul>
<li><a href="api/Attribute-Retrieval-API.html">Attribute Lookup Methods</a> - for retrieving names, email addresses, etc.</li>
<li><a href="api/Message-Sending-API.html">Sending Messages and Replies</a> - for sending messages to the users</li>
<li><a href="api/Response-Request-API.html">Prompting for Input</a> - for getting replies from the user</li>
<li><a href="api/Brain-API.html">Brain Methods and Memories</a> - for storing and retrieving long- and short-term memories</li>
<li><a href="api/Utility-API.html">Utility Methods</a> - a collection of miscellaneous useful functions, like Pause() and Log()</li>
</ul>
<h1><a class="header" href="#getting-information-about-users-and-the-robot" id="getting-information-about-users-and-the-robot">Getting Information About Users and the Robot</a></h1>
<p>The <code>Get*Attribute(...)</code> family of methods can be used to get basic chat service directory information like first and last name, email address, etc. <code>GetSenderAttribute</code> and <code>GetBotAttribute</code> take a single argument, the name of the attribute to retrieve. The lesser-used <code>GetUserAttribute</code> takes two arguments, the user and the attribute. The return value is an object with <code>Attribute</code> and <code>RetVal</code> members. <code>RetVal</code> will be one of <code>Ok</code>, <code>UserNotFound</code> or <code>AttributeNotFound</code>.</p>
<h2><a class="header" href="#user-attributes" id="user-attributes">User Attributes</a></h2>
<p>The available attributes for a user / sender:</p>
<ul>
<li>name (handle)</li>
<li>fullName</li>
<li>email</li>
<li>firstName</li>
<li>lastName</li>
<li>phone</li>
<li>internalID (protocol internal representatation)</li>
</ul>
<h2><a class="header" href="#bot-attributes" id="bot-attributes">Bot Attributes</a></h2>
<p>The available attributes for the bot:</p>
<ul>
<li>name</li>
<li>alias</li>
<li>fullName / realName</li>
<li>contact / admin / adminContact</li>
<li>email</li>
<li>protocol (e.g. &quot;slack&quot;)</li>
</ul>
<p>Note: the values for most of these are configured in <code>conf/robot.yaml</code></p>
<h1><a class="header" href="#code-examples" id="code-examples">Code Examples</a></h1>
<h2><a class="header" href="#bash" id="bash">Bash</a></h2>
<pre><code class="language-bash">USEREMAIL=$(GetSenderAttribute email)
if [ $? -ne $GBRET_Ok ]
then
  Say &quot;I was unable to look up your email address&quot;
else
  Say &quot;Your email address is $USEREMAIL&quot;
fi
</code></pre>
<h2><a class="header" href="#powershell" id="powershell">PowerShell</a></h2>
<pre><code class="language-powershell">$attr = $bot.GetBotAttribute(&quot;email&quot;)
if ( $attr.Ret -eq &quot;Ok&quot; ) {
  $email = $attr.Attr
  $bot.Say(&quot;My email address is: $email&quot;)
} else {
  $bot.Say(&quot;I don't think I have an email address&quot;)
}
</code></pre>
<h2><a class="header" href="#python" id="python">Python</a></h2>
<pre><code class="language-python"># In some cases you might forego error checking
bot.Say(&quot;You can send email to %s&quot; % bot.GetBotAttribte(&quot;email&quot;))
botNameAttr = bot.GetBotAttribute(&quot;fullName&quot;)
if botNameAttr.ret == Robot.Ok:
  bot.Say(&quot;My full name is %s&quot; % botNameAttr)
else:
  bot.Say(&quot;I don't even know what my name is!&quot;)
</code></pre>
<h2><a class="header" href="#ruby" id="ruby">Ruby</a></h2>
<pre><code class="language-ruby"># In some cases you might forego error checking
bot.Say(&quot;You can send email to #{bot.GetBotAttribute(&quot;email&quot;)}&quot;)
botNameAttr = bot.GetBotAttribute(&quot;fullName&quot;)
if botNameAttr.ret == Robot::Ok
  bot.Say(&quot;My full name is #{botNameAttr}&quot;)
else
  bot.Say(&quot;I don't even know what my name is!&quot;)
end
</code></pre>
<p><strong>Gopherbot</strong> comes with brain methods allowing plugin authors to store information long-term information like a <code>TODO</code> list, or short-term contextual
information, such as a particular list item under discussion. An important supplement to this guide can be found in the example scripting
plugins in the <code>plugins/</code> directory, and the <code>links</code> and <code>lists</code> <em>Go</em> plugins in the <code>goplugins</code> directory (from the source,
not included in the distributed <code>.zip</code> files).</p>
<h1><a class="header" href="#table-of-contents-1" id="table-of-contents-1">Table of Contents</a></h1>
<ul>
<li><a href="api/Brain-API.html#memory-scoping">Memory Scoping</a></li>
<li><a href="api/Brain-API.html#long-term-memories">Long-Term Memories</a>
<ul>
<li><a href="api/Brain-API.html#long-term-memory-code-examples">Code Examples</a></li>
<li><a href="api/Brain-API.html#long-term-memory-sample-transcript">Sample Transcript</a></li>
</ul>
</li>
<li><a href="api/Brain-API.html#short-term-memories">Short-Term Memories</a>
<ul>
<li><a href="api/Brain-API.html#method-summary">Method Summary</a></li>
<li><a href="api/Brain-API.html#short-term-memory-code-examples">Code Examples</a></li>
<li><a href="api/Brain-API.html#short-term-memory-sample-transcript">Sample Transcript</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#memory-scoping" id="memory-scoping">Memory Scoping</a></h1>
<p>Long-term memories are scoped per-plugin by key, and so the data is not shareable between plugins. Short-term memories are stored
for each user/channel combination, and can be freely shared between plugins.</p>
<h1><a class="header" href="#long-term-memories-1" id="long-term-memories-1">Long-Term Memories</a></h1>
<p>The following methods are available for manipulating long-term memories:</p>
<ul>
<li><code>CheckoutDatum(key, RWflag)</code> - returns a complex data item (memory) with a short-term exclusive lock on the datum if RW is <code>true</code></li>
<li><code>CheckinDatum(memory)</code> - signals the robot to release the lock without updating</li>
<li><code>UpdateDatum(memory)</code> - updates the memory and releases the lock</li>
</ul>
<h2><a class="header" href="#long-term-memory-code-examples" id="long-term-memory-code-examples">Long-Term Memory Code Examples</a></h2>
<p>The memory stored can be an arbitrarily complex data item; a hash, array, or combination - anything that can be serialized to/from
JSON. The example plugins for <strong>Python</strong>, <strong>Ruby</strong> and <strong>PowerShell</strong> all implement a <em>remember</em> function that remembers a list (array)
of items. For the code examples, we'll start with a memory whose key is <code>memory</code>, and has two items defined by this snippet of JSON:</p>
<pre><code class="language-json">[&quot;the Alamo&quot;, &quot;Ferris Bueller&quot;]
</code></pre>
<p>The examples will check if the memory exists, add &quot;the answer is 42&quot;, and then update the memory.</p>
<p>Note that long-term memory commands aren't current implemented for <code>bash</code>.</p>
<h3><a class="header" href="#python-1" id="python-1">Python</a></h3>
<pre><code class="language-python">memory = bot.CheckoutDatum(&quot;memory&quot;, True)
if memory.exists:
    memory.datum.append(&quot;the answer is 42&quot;)
else:
    memory.datum = [ thing ]
ret = bot.UpdateDatum(memory)
if ret != Robot.Ok:
    bot.Say(&quot;Uh-oh, I must be gettin' old - having memory problems!&quot;)
</code></pre>
<h3><a class="header" href="#ruby-1" id="ruby-1">Ruby</a></h3>
<p>Note: the Ruby example is a little more complicated; adapted from plugins/rubydemo.rb.</p>
<pre><code class="language-ruby">memory = bot.CheckoutDatum(&quot;memory&quot;, true)
remembered = false
if memory.exists
  if memory.datum.include?(thing)
    bot.Say(&quot;That's already one of my fondest memories&quot;)
    bot.CheckinDatum(memory)
  else
    remembered = true
    memory.datum.push(&quot;the answer is 42&quot;)
  end
else
  remembered = true
  memory.datum = [ &quot;the answer is 42&quot; ]
end
if remembered
  ret = bot.UpdateDatum(memory)
  if ret != Robot::Ok
    bot.Say(&quot;Dang it, having problems with my memory&quot;)
  end
end
</code></pre>
<h3><a class="header" href="#powershell-1" id="powershell-1">PowerShell</a></h3>
<pre><code class="language-powershell">$memory = $bot.CheckoutDatum(&quot;memory&quot;, $TRUE)
if ($memory.exists) {
  $memory.Datum += &quot;the answer is 42&quot;
} else {
  [String[]] $memory.Datum = @( &quot;the answer is 42&quot; )
}
$ret = $bot.UpdateDatum($memory)
if ($ret -ne &quot;Ok&quot;) {
  $bot.Say(&quot;I'm having a hard time remembering things&quot;)
}
</code></pre>
<h2><a class="header" href="#long-term-memory-sample-transcript" id="long-term-memory-sample-transcript">Long-Term Memory Sample Transcript</a></h2>
<p>Using the <code>terminal</code> connector, you can see the <code>remember</code> function in action:</p>
<pre><code>c:general/u:alice -&gt; floyd, remember the answer is 42
general: Ok, I'll remember &quot;the answer is 42&quot;
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; floyd, recall
general: Here's everything I can remember:
#1: the Alamo
#2: Ferris Bueller
#3: the answer is 42
</code></pre>
<p>From the transcript you can see that <code>alice</code> added the item to the list, which
was then visible to <code>bob</code>. The <code>links</code> and <code>lists</code> plugins are more useful, and
allow easy sharing of bookmark items or <code>TODO</code> lists, for example.</p>
<h1><a class="header" href="#short-term-memories" id="short-term-memories">Short-Term Memories</a></h1>
<p>Short term memories are simple key -&gt; string values stored for each user / channel combination, and expiring
after a time. The best example of this uses the built-in <code>links</code> and <code>lists</code> plugins, shown in this example
using the <code>terminal</code> plugin:</p>
<pre><code>c:general/u:alice -&gt; link tuna casserole to https://www.allrecipes.com/recipe/17219/best-tuna-casserole/, floyd
general: Link added
c:general/u:alice -&gt; add it to the dinner meals list
c:general/u:alice -&gt; floyd
general: Ok, I added tuna casserole to the dinner meals list
c:general/u:alice -&gt; floyd
general: Yes?
c:general/u:bob -&gt; floyd, pick a random item from the dinner meals list
general: Here you go: tuna casserole
c:general/u:bob -&gt; look it up, floyd
general: Here's what I have for &quot;tuna casserole&quot;:
https://www.allrecipes.com/recipe/17219/best-tuna-casserole/: tuna casserole
</code></pre>
<p>Here, the robot is using short-term memories several times. When I forgot to address my command to the robot, the command
<code>add it to the dinner meals list</code> was stored in short-term memory for user <code>alice</code> in the <code>general</code> channel; then, when
I typed the robot's name, it checked short-term memory for the last thing <code>alice</code> said (stored automatically). Then,
the <code>links</code> plugin stored <code>tuna casserole</code> in the <code>item</code> short-term contextual memory; when I used <code>it</code> in the lists command,
the lists plugin checked the <code>item</code> short-term memory (see <code>contexts</code> in the plugin config for <code>lists</code>) and
substituted the value from the short-term memory.</p>
<h2><a class="header" href="#method-summary" id="method-summary">Method Summary</a></h2>
<p>These methods are available for short-term memories:</p>
<ul>
<li><code>Remember(key, value)</code> - associate the string <code>value</code> to <code>key</code>, always returns <code>Ok</code></li>
<li><code>RememberContext(context, value)</code> - store a short-term contextual memory for use with other plugins</li>
<li><code>Recall(key)</code> - return the short-term memory associated with <code>key</code>, or the empty string when the memory doesn't exist</li>
</ul>
<p>Note that the short-term memory API doesn't have complicated return values. They are always stored in the robot's working
memory and never persisted, and expire after several minutes - so plugins should always be prepared to get blank return
values.</p>
<h2><a class="header" href="#short-term-memory-code-examples" id="short-term-memory-code-examples">Short-Term Memory Code Examples</a></h2>
<p>Note that the short-term memory API is super trivial, so I didn't go to great lengths to provide
detailed examples. The <code>bash</code> example comes from the <code>bashdemo.sh</code> plugin.</p>
<h3><a class="header" href="#bash-1" id="bash-1">Bash</a></h3>
<pre><code class="language-bash">Remember &quot;$1&quot; &quot;$2&quot;
Say &quot;I'll remember \&quot;$1\&quot; is \&quot;$2\&quot; - but eventually I'll forget!&quot;
</code></pre>
<pre><code class="language-bash">MEMORY=$(Recall &quot;$1&quot;)
if [ -z &quot;$MEMORY&quot; ]
then
	Reply &quot;Gosh, I have no idea - I'm so forgetful!&quot;
else
	Say &quot;$1 is $MEMORY&quot;
fi
</code></pre>
<h3><a class="header" href="#python-2" id="python-2">Python</a></h3>
<pre><code class="language-python">bot.Remember(key, value)
</code></pre>
<pre><code class="language-python">mem = bot.Recall(key)
</code></pre>
<h3><a class="header" href="#ruby-2" id="ruby-2">Ruby</a></h3>
<pre><code class="language-ruby">bot.Remember(key, value)
</code></pre>
<pre><code class="language-ruby">mem = bot.Recall(key)
</code></pre>
<h3><a class="header" href="#powershell-2" id="powershell-2">PowerShell</a></h3>
<pre><code class="language-powershell">$bot.Remember($key, $value)
</code></pre>
<pre><code class="language-powershell">$mem = $bot.Recall($key)
</code></pre>
<h2><a class="header" href="#short-term-memory-sample-transcript" id="short-term-memory-sample-transcript">Short-Term Memory Sample Transcript</a></h2>
<p>Here you can see the robot's short term memories of Ferris Bueller in action (using
the <code>bashdemo.sh</code> plugin):</p>
<pre><code>c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: @bob Gosh, I have no idea - I'm so forgetful!
c:general/u:bob -&gt; floyd, store Ferris Bueller is a Righteous Dude
general: I'll remember &quot;Ferris Bueller&quot; is &quot;a Righteous Dude&quot; - but eventually I'll forget!
c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: Ferris Bueller is a Righteous Dude
c:general/u:bob -&gt; |ualice
Changed current user to: alice
c:general/u:alice -&gt; floyd, what is Ferris Bueller
general: @alice Gosh, I have no idea - I'm so forgetful!
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: Ferris Bueller is a Righteous Dude
</code></pre>
<h1><a class="header" href="#table-of-contents-2" id="table-of-contents-2">Table of Contents</a></h1>
<ul>
<li><a href="api/Message-Sending-API.html#message-formatting">Message Formatting</a></li>
<li><a href="api/Message-Sending-API.html#say-and-reply">Say and Reply</a></li>
<li><a href="api/Message-Sending-API.html#sendusermessage-sendchannelmessage-and-senduserchannelmessage">SendUserMessage, SendChannelMessage and SendUserChannelMessage</a></li>
<li><a href="api/Message-Sending-API.html#code-examples">Code Examples</a>
<ul>
<li><a href="api/Message-Sending-API.html#bash">Bash</a></li>
<li><a href="api/Message-Sending-API.html#powershell">PowerShell</a></li>
<li><a href="api/Message-Sending-API.html#python">Python</a></li>
<li><a href="api/Message-Sending-API.html#ruby">Ruby</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#messageformat-method-and-message-formatting" id="messageformat-method-and-message-formatting">MessageFormat method and Message Formatting</a></h1>
<p><strong>Gopherbot</strong> is designed to provide ChatOps functionality for a variety of team
chat platforms, with Slack being the first. Due to the technical nature of ChatOps,
characters like <code>_</code>, <code>*</code> and ` may need to be rendered in replies to the user;
at times omitting these characters (because they cause formatting changes) could
remove important information. To provide the plugin author with the most flexibility,
<strong>Gopherbot</strong> supports the notion of three message formats:</p>
<ul>
<li><code>Raw</code> - text sent by a plugin with <code>Raw</code> format is passed straight to the chat platform as-is; this is the default if no other default is specified</li>
<li><code>Variable</code> - for the <code>Variable</code> format, the protocol connector should attempt to process the message so that special characters are escaped or otherwise modified to render for the user in a standard variable-width font; for Slack, special characters are surrounded by nulls</li>
<li><code>Fixed</code> - the protocol connector should render <code>Fixed</code> format messages in a fixed-width block format</li>
</ul>
<p>The <code>MessageFormat(raw|variable|fixed)</code> method returns a robot object with the specified format. A plugin can use
<code>GetBotAttribute(&quot;protocol&quot;)</code> to determine the connector protocol (e.g. &quot;slack&quot;) to make intelligent decisions
about the format to use, or modify the content of raw messages depending on the connection protocol.</p>
<h1><a class="header" href="#say-and-reply" id="say-and-reply">Say and Reply</a></h1>
<p><code>Say</code> and <code>Reply</code> are the staples of message sending. Both are generally used for replying to the person who spoke to the robot, but <code>Reply</code> will also <em>mention</em> the user. Normally, <code>Say</code> is used when the robot responds immediately to the user, but <code>Reply</code> is used when the robot is performing a task that takes more than a few minutes, and the robot needs to direct the message to the user to update them with progress on the task. Both <code>Say</code> and <code>Reply</code> take a <code>message</code> argument, and an optional second <code>format</code> argument that can be <code>variable</code> (the default) for variable-width text, or <code>fixed</code> for fixed-width text. The <code>fixed</code> format is normally used with embedded newlines to create tabular output where the columns will line up. The return value is not normally checked, but can be one of <code>Ok</code>, <code>UserNotFound</code>, <code>ChannelNotFound</code>, or <code>FailedMessageSend</code>.</p>
<h1><a class="header" href="#sendusermessage-sendchannelmessage-and-senduserchannelmessage" id="sendusermessage-sendchannelmessage-and-senduserchannelmessage">SendUserMessage, SendChannelMessage and SendUserChannelMessage</a></h1>
<p><code>Say</code> and <code>Reply</code> are actually convenience wrappers for the <code>Send*Message</code> family of methods. <code>SendChannelMessage</code> takes the obvious arguments of <code>channel</code> and <code>message</code> and just writes a message to a channel. <code>SendUserMessage</code> sends a direct message to a user, and <code>SendUserChannelMessage</code> directs the message to a user in a channel by using a connector-specific <em>mention</em>. Like <code>Say</code> and <code>Reply</code>, each of these functions also takes an optional <code>format</code> argument, and uses the same return values.</p>
<h1><a class="header" href="#code-examples-1" id="code-examples-1">Code Examples</a></h1>
<h2><a class="header" href="#bash-2" id="bash-2">Bash</a></h2>
<pre><code class="language-bash"># Note that bash isn't object-oriented
Say &quot;I'm sending a message to Bob in #general&quot;
SendUserChannelMessage &quot;bob&quot; &quot;general&quot; &quot;Hi, Bob!&quot;
RETVAL = $?
if [ $RETVAL -ne $GBRET_Ok ]
then
  Log &quot;Error&quot; &quot;Unable to message Bob in #general - return code $RETVAL&quot;
fi
</code></pre>
<h2><a class="header" href="#powershell-3" id="powershell-3">PowerShell</a></h2>
<pre><code class="language-powershell">$bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
$retval = $bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if ( $retval -ne &quot;Ok&quot; ) {
  $bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code $retval&quot;)
}
</code></pre>
<h2><a class="header" href="#python-3" id="python-3">Python</a></h2>
<pre><code class="language-python">bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
retval = bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if ( retval != Robot.Ok ):
  bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code %d&quot; % retval)
</code></pre>
<h2><a class="header" href="#ruby-3" id="ruby-3">Ruby</a></h2>
<pre><code class="language-ruby">bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
retval = bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if retval != Robot::Ok
  bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code %d&quot; % retval)
end
</code></pre>
<p><strong>Gopherbot</strong> takes a slightly different approach to creating pipelines; pipelines are created by Add/Fail/Final Job/Command/Task family of methods, rather than by fixed configuration directives. This allows flexible configuration of pipelines if desired for e.g. a CI/CD application, or dynamic generation of pipelines based on logic at runtime.</p>
<p>Until more documentation is written, see:</p>
<ul>
<li><a href="https://github.com/lnxjedi/gopherbot/blob/master/.gopherci/pipeline.sh">The Gopherbot Pipeline Source</a></li>
<li><a href="https://github.com/parsley42/floyd-gopherbot">The Configuration repository for Floyd, the robot that builds Gopherbot</a></li>
</ul>
<h1><a class="header" href="#table-of-contents-3" id="table-of-contents-3">Table of Contents</a></h1>
<ul>
<li><a href="api/Pipeline-API.html#addtask">AddTask</a></li>
<li><a href="api/Pipeline-API.html#setparameter">SetParameter</a></li>
</ul>
<h2><a class="header" href="#addtask" id="addtask">AddTask</a></h2>
<p>The <code>AddTask</code> method ... TODO: finish me!</p>
<h3><a class="header" href="#bash-3" id="bash-3">Bash</a></h3>
<pre><code class="language-bash">AddTask &quot;echo&quot; &quot;hello, world&quot;
</code></pre>
<h3><a class="header" href="#python-4" id="python-4">Python</a></h3>
<pre><code class="language-python"></code></pre>
<h3><a class="header" href="#ruby-4" id="ruby-4">Ruby</a></h3>
<pre><code class="language-ruby"></code></pre>
<h3><a class="header" href="#powershell-4" id="powershell-4">PowerShell</a></h3>
<pre><code class="language-powershell">$ret = $bot.AddTask(&quot;echo&quot;, @(&quot;hello&quot;, &quot;world&quot;))
</code></pre>
<h2><a class="header" href="#setparameter" id="setparameter">SetParameter</a></h2>
<p>The <code>Prompt*ForReply</code> methods make it simple to write interactive plugins where the bot can request additional input from the user.</p>
<h1><a class="header" href="#table-of-contents-4" id="table-of-contents-4">Table of Contents</a></h1>
<ul>
<li><a href="api/Response-Request-API.html#technical-background">Technical Background</a></li>
<li><a href="api/Response-Request-API.html#prompting-methods">Prompting Methods</a>
<ul>
<li><a href="api/Response-Request-API.html#method-arguments">Method Arguments</a></li>
<li><a href="api/Response-Request-API.html#return-values">Return Values</a></li>
</ul>
</li>
<li><a href="api/Response-Request-API.html#code-examples">Code Examples</a>
<ul>
<li><a href="api/Response-Request-API.html#bash">Bash</a></li>
<li><a href="api/Response-Request-API.html#powershell">PowerShell</a></li>
<li><a href="api/Response-Request-API.html#python">Python</a></li>
<li><a href="api/Response-Request-API.html#ruby">Ruby</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#technical-background" id="technical-background">Technical Background</a></h2>
<p>Interactive plugins are complicated by the fact that multiple plugins can be running simultaneously and each can request input from the user. <strong>Gopherbot</strong> handles requests for replies this way:</p>
<ol>
<li>If there are no other plugins waiting for a reply for the given user/channel, the robot emits the prompt and waits to hear back from the user</li>
<li>If other plugins are waiting for a reply, the prompt is not emitted and the request goes in to a list of waiters</li>
<li>As other plugins get replies (or timeout while waiting), waiters in the list get a <code>RetVal</code> of <code>RetryPrompt</code>, indicating they should issue the prompt request again (this is handled internally in individual scripting libraries)</li>
</ol>
<h2><a class="header" href="#prompting-methods" id="prompting-methods">Prompting Methods</a></h2>
<p>The following methods are available for prompting for replies:</p>
<ul>
<li><code>PromptForReply(regexID string, prompt string)</code> - issue a prompt to whoever/wherever the original command was issued</li>
<li><code>PromptUserForReply(regexID string, user string, prompt string)</code> - for prompting the user in a direct message (DM) (for e.g. a password or other sensitive information)</li>
<li><code>PromptUserChannelForReply(regexID string, user string, channel string, prompt string)</code> - prompt a specific user in a specific channel (for e.g. getting approval from another user for an action)</li>
</ul>
<h3><a class="header" href="#method-arguments" id="method-arguments">Method arguments</a></h3>
<p>The <code>user</code> and <code>channel</code> arguments are obvious; the <code>prompt</code> is the question the robot is
asking the user, and should usually end with a <code>?</code>.</p>
<p>The <code>regexID</code> should correspond to a <code>ReplyMatcher</code> defined in the plugin configuration,
(see <a href="api/Configuration.html#plugin-configuration">Plugin Configuration</a>), or one of the
built-in regex's:</p>
<ul>
<li><code>Email</code></li>
<li><code>Domain</code> - an alpha-numeric domain name</li>
<li><code>OTP</code> - a 6-digit one-time password code</li>
<li><code>IPAddr</code></li>
<li><code>SimpleString</code> - Characters commonly found in most english sentences, doesn't include special characters like @, {, etc.</li>
<li><code>YesNo</code></li>
</ul>
<h3><a class="header" href="#return-values" id="return-values">Return Values</a></h3>
<p>Two distinct values are returned from the prompting methods:</p>
<ol>
<li>A <code>RetVal</code> indicating success or error condition - <code>Reply.ret</code></li>
<li>When <code>RetVal</code> == <code>Ok</code>, the matched string is also returned - <code>Reply.reply</code></li>
</ol>
<p>In <strong>Go</strong>, these are returned as two separate values; in most scripting
languages, these are returned as a compound object whose string representation
is the returned string in <code>Reply.reply</code> (if the <code>RetVal</code> was <code>Ok</code>, otherwise it's the empty string).</p>
<p>Possible values for the <code>RetVal</code> in <code>Reply.ret</code> are:</p>
<ul>
<li><code>Ok</code> - If the user replied and the reply matched the regex identified by <code>regexID</code></li>
<li><code>UserNotFound</code>, <code>ChannelNotFound</code> - When an invalid user / channel is provided</li>
<li><code>MatcherNotFound</code> - When an invalid matcher is supplied</li>
<li><code>Interrupted</code> - If the user issues a new command to the robot (see NOTE below), too many <code>RetryPrompt</code> values are returned (&gt;3), or the user replies with a single dash: '<code>-</code>' (cancel)</li>
<li><code>TimeoutExpired</code> - If the user says nothing for 45 seconds</li>
<li><code>UseDefaultValue</code> - If the user replied with a single equal sign (<code>=</code>)</li>
<li><code>ReplyNotMatched</code> - When the reply from the user didn't match the supplied regex (the user was probably talking to somebody else)</li>
</ul>
<h2><a class="header" href="#code-examples-2" id="code-examples-2">Code Examples</a></h2>
<h3><a class="header" href="#bash-4" id="bash-4">Bash</a></h3>
<pre><code class="language-bash"># Note that bash isn't object-oriented
REPLY=$(PromptForReply &quot;YesNo&quot; &quot;Do you like kittens?&quot;)
if [ $? -ne 0 ]
then
	Reply &quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;
else
  if [[ $REPLY == y* ]] || [[ $REPLY == Y* ]]
  then
    Say &quot;No kidding! Me too!&quot;
  else
    Say &quot;Oh, come on - you're kidding, right?!?&quot;
  fi
fi
</code></pre>
<h3><a class="header" href="#powershell-5" id="powershell-5">PowerShell</a></h3>
<pre><code class="language-powershell">$rep = $bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if ($rep.Ret -ne &quot;Ok&quot;) {
  $bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
} else {
  $reply = [String]$rep
  switch -Wildcard ($reply) {
    &quot;y*&quot; { # PS is case-insensitive
      $bot.Say(&quot;No kidding! Me too!&quot;)
    }
    default {
      $bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
    }
  }
}
</code></pre>
<h3><a class="header" href="#python-5" id="python-5">Python</a></h3>
<pre><code class="language-python">rep = bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if rep.ret != Robot.Ok:
  bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
else:
  reply = rep.__str__()
  if re.match(&quot;y.*&quot;, reply, flags=re.IGNORECASE):
    bot.Say(&quot;No kidding! Me too!&quot;)
  else:
    bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
</code></pre>
<h3><a class="header" href="#ruby-5" id="ruby-5">Ruby</a></h3>
<pre><code class="language-ruby">rep = bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if rep.ret != Robot::Ok
  bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
else
  reply = rep.to_s()
  if /y.*/i =~ reply
    bot.Say(&quot;No kidding! Me too!&quot;)
  else
    bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
  end
end
</code></pre>
<h1><a class="header" href="#log-method" id="log-method">Log Method</a></h1>
<p>Besides the logging that Gopherbot does on it's own, plugins can also emit log messages with one of the following log levels:</p>
<ul>
<li><code>Trace</code> - for fine-grained logging of all actions</li>
<li><code>Debug</code> - for emitting debugging info</li>
<li><code>Info</code> - the default log level</li>
<li><code>Audit</code> - for auditable events - <strong>NOTE:</strong> <em>Audit events are always logged regardless of the current log level</em></li>
<li><code>Warn</code> - for potentially harmful events</li>
<li><code>Error</code> - for errors</li>
<li><code>Fatal</code> - emit fatal error and cause robot to exit(1)</li>
</ul>
<h2><a class="header" href="#bash-5" id="bash-5">Bash</a></h2>
<pre><code class="language-bash">Log &quot;Error&quot; &quot;The robot broke&quot;
</code></pre>
<h2><a class="header" href="#powershell-6" id="powershell-6">PowerShell</a></h2>
<pre><code class="language-powershell">$bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h2><a class="header" href="#python-6" id="python-6">Python</a></h2>
<pre><code class="language-python">bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h2><a class="header" href="#ruby-6" id="ruby-6">Ruby</a></h2>
<pre><code class="language-ruby">bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h1><a class="header" href="#pause-method" id="pause-method">Pause Method</a></h1>
<p>Every language has some means of sleeping / pausing, and this method is provided as a convenience to plugin authors and implemented natively. It takes a single argument, time in seconds.</p>
<h2><a class="header" href="#bash-6" id="bash-6">Bash</a></h2>
<pre><code class="language-bash">Say &quot;Be back soon!&quot;
Pause 2
Say &quot;... aaaand I'm back!&quot;
</code></pre>
<h2><a class="header" href="#powershell-7" id="powershell-7">PowerShell</a></h2>
<pre><code class="language-powershell">$bot.Say(&quot;Be back soon!&quot;)
$bot.Pause(2)
$bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2><a class="header" href="#python-7" id="python-7">Python</a></h2>
<pre><code class="language-python">bot.Say(&quot;Be back soon!&quot;)
bot.Pause(2)
bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2><a class="header" href="#ruby-7" id="ruby-7">Ruby</a></h2>
<pre><code class="language-ruby">bot.Say(&quot;Be back soon!&quot;)
bot.Pause(2)
bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2><a class="header" href="#gopherbot-loadable-module-support" id="gopherbot-loadable-module-support">Gopherbot Loadable Module Support</a></h2>
<p><strong>Gopherbot's</strong> loadable module support now allows new or updated <strong>Go</strong> plugins to be loaded in to a running robot (though it requires a full restart).</p>
<h1><a class="header" href="#jobs-and-pipelines" id="jobs-and-pipelines">Jobs and Pipelines</a></h1>
<h1><a class="header" href="#included-tasks" id="included-tasks">Included Tasks</a></h1>
<p><strong>Gopherbot</strong> ships with a selection of available pipeline tasks, listed here:</p>
<ul>
<li><code>pause-brain</code> (privileged) - pauses brain operations to allow backups, auto-resume after a timeout</li>
<li><code>resume-brain</code> (privileged) - resumes brain operations</li>
<li><code>restart-robot</code> (privileged) - restarts the robot</li>
<li><code>rotate-log</code> (privileged) - start a new logfile</li>
</ul>
<p><strong>NOTE on Parameters and Environment Variables</strong>: The <strong>Gopherbot</strong> documentation uses <em>environment variable</em> and <em>parameter</em> somewhat interchangeably; this is due to configured parameters being made available to external scripts as environment variables.</p>
<h1><a class="header" href="#task-environment-variables" id="task-environment-variables">Task Environment Variables</a></h1>
<p>Each time a task is run, a custom environment is generated for that task. For external tasks such as <code>ssh-init</code>, these values are actually set as environment variables for the process. <em>Go</em> tasks access these values with the <code>GetParameter()</code> API call.</p>
<p>The precedence of environment variables seen by a given task is determined by the algorithm in <code>bot/runtasks.go:getEnvironment()</code>. The various environment sources are listed here, in order from least to highest priority.</p>
<h2><a class="header" href="#namespace-parameters" id="namespace-parameters">NameSpace Parameters</a></h2>
<p>Various tasks, plugins and jobs can be configured to share parameters by defining <code>NameSpaces</code> in <code>conf/robot.yaml</code>, and setting the <code>NameSpace</code> parameter for a given task to the shared namespace. For instance, the <code>ssh-init</code> task and <code>ssh-admin</code> plugin both get access to the <code>BOT_SSH_PHRASE</code> environment variable via the <code>ssh</code> namespace.</p>
<h2><a class="header" href="#task-parameters" id="task-parameters">Task Parameters</a></h2>
<p>Individual tasks, plugins and jobs can also have <code>Parameters</code> defined. If present, these override any parameters set for a shared namespace.</p>
<h2><a class="header" href="#pipeline-parameters" id="pipeline-parameters">Pipeline Parameters</a></h2>
<p>Any time a job is run, the parameters for that job (including those inherited from it's namespace, if any) initialize the environment variables for the pipeline as a whole, and are available to all tasks in the pipeline. Parameters set in the pipeline override task and namespace parameters for any tasks run in the pipeline, allowing specific job parameters to override defaults for the task.</p>
<h3><a class="header" href="#plugins-and-pipelines" id="plugins-and-pipelines">Plugins and Pipelines</a></h3>
<p>Plugins can also start a new pipeline, but plugin parameters are not automatically added to the pipeline. Plugins can, however, explicity publish parameters to the pipeline with the <code>SetParameter()</code> API call.</p>
<p>Plugin tasks can also be added to a pipeline with the <code>AddCommand()</code>, <code>FinalCommand()</code> and <code>FailCommand()</code> API calls. Unlike tasks, plugins only inherit parameters from the pipeline when they are configured with <code>Privileged: true</code> in <code>robot.yaml</code>.</p>
<h2><a class="header" href="#repository-parameters" id="repository-parameters">Repository Parameters</a></h2>
<p>If a given Job calls the <code>ExtendNamespace()</code> API to start a build, the parameters for that repository set in <code>conf/repositories.yaml</code> overwrite any values in the current pipeline, which then behave as <strong>Pipeline Parameters</strong> as above.</p>
<h2><a class="header" href="#setparameter-1" id="setparameter-1">SetParameter()</a></h2>
<p>Parameters set with the <code>SetParameter()</code> API call overwrite the current value for a pipeline; thus, it makes little sense to call <code>SetParameter()</code> before <code>ExtendNamespace()</code>. Parameters set with <code>SetParameter()</code> have the highest priority, and will always apply to further tasks in the pipeline.</p>
<h1><a class="header" href="#tool-integrations" id="tool-integrations">Tool Integrations</a></h1>
<p>To simplify using tools like <code>ssh</code> and <code>ansible</code> in your pipeline, <strong>Gopherbot</strong> ships with some predefined pipeline elements detailed in the following sections.</p>
<h1><a class="header" href="#integrating-with-ssh" id="integrating-with-ssh">Integrating with SSH</a></h1>
<p>The <strong>GopherCI</strong> job(s) use <em>ssh</em> tasks for cloning repositories with public keys, and you can also use these tasks in your own pipelines for executing remote tasks.</p>
<h2><a class="header" href="#configuring-ssh" id="configuring-ssh">Configuring SSH</a></h2>
<p>You start by choosing a passphrase for your robot's ssh keypair - make it something quite long; you shouldn't need to type it more than once. Use the <code>encrypt</code> command (normally with the terminal connector) to produce the encrypted value, and put it in a stanza like the following in your <code>robot.yaml</code>:</p>
<pre><code class="language-yaml">ExternalTasks:
  &quot;ssh-init&quot;:
    Parameters:
    - Name: BOT_SSH_PHRASE
      Value: {{ decrypt &quot;xxxxx&quot; }}
</code></pre>
<h2><a class="header" href="#initializing" id="initializing">Initializing</a></h2>
<p>Once the robot knows it's passphrase, you can use the <code>generate keypair</code> administrator command to generate a new keypair, which will be stored in <code>$GOPHER_CONFIGDIR/ssh/</code>. The private key is encrypted with the robot's (also encrypted) passphrase, so this can be committed to the repository. The <code>pubkey</code> administrator command will display the robot's public key.</p>
<h2><a class="header" href="#using-in-pipelines" id="using-in-pipelines">Using in Pipelines</a></h2>
<p>A pipeline using <em>ssh</em> might look something like this:</p>
<pre><code class="language-bash">AddTask ssh-init

AddTask ssh-scan my.remote.host

AddTask exec ssh $SSH_OPTIONS user@my.remote.host &quot;whoami&quot;
</code></pre>
<ul>
<li>The <code>ssh-init</code> task will:
<ul>
<li>Start an <code>ssh-agent</code> and add the robot's key</li>
<li>Use <code>SetParameter</code> to store <code>SSH_AUTH_SOCK</code> and <code>SSH_AGENT_PID</code> in the pipeline</li>
<li>Set <code>SSH_OPTIONS</code> to e.g. <code>-F $GOPHER_CONFIGDIR/ssh/config</code> if the robot has a custom ssh config file</li>
<li>Add a <strong>FinalTask</strong> to kill the <code>ssh-agent</code> when the pipeline finishes</li>
</ul>
</li>
<li><code>ssh-scan</code> insures a host is listed in <code>known_hosts</code>, if desired (this may be unneeded depending on the contents of <code>ssh/config</code>)</li>
<li>The <code>exec</code> task calls ssh as normal, using <code>$SSH_OPTIONS</code> to pick up custom configuration if it exists</li>
</ul>
<h1><a class="header" href="#working-on-gopherbot" id="working-on-gopherbot">Working on Gopherbot</a></h1>
<p>This chapter outlines the tools and methods for working on <strong>Gopherbot</strong> itself.</p>
<h1><a class="header" href="#development-robot" id="development-robot">Development Robot</a></h1>
<h1><a class="header" href="#developing-integration-tests" id="developing-integration-tests">Developing Integration Tests</a></h1>
<p>The current testing methodology for <strong>Gopherbot</strong> uses a special <code>test</code> protocol connector for sending test commands to the engine from various users in various channels, and then examining the responses and events generated. The tests themselves and test configurations are located in <code>/test</code>.</p>
<h2><a class="header" href="#building-the-special-testbot" id="building-the-special-testbot">Building the special &quot;testbot&quot;</a></h2>
<p>The <strong>Gopherbot</strong> <code>Makefile</code> includes a special &quot;testbot&quot; target that builds the robot with a modified version of the terminal connector:</p>
<pre><code class="language-shell">$ make testbot
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -mod vendor -tags 'netgo osusergo static_build test' -o gopherbot
</code></pre>
<h2><a class="header" href="#developing-tests" id="developing-tests">Developing Tests</a></h2>
<p>See the contents of <code>test/*_test.go</code> for the format of the tests. After any given exchange with the robot, pressing <code>&lt;enter&gt;</code> by itself gives the events generated. Here's an example session for developing the tests in <code>test/bot_integration_test.go:TestPrompting</code>:</p>
<pre><code class="language-shell">$ make testbot
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -mod vendor -tags 'netgo osusergo static_build test' -o gopherbot
[gopherbot]$ cd test/membrain
[membrain]$ ../../gopherbot 
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
...
</code></pre>
<h2><a class="header" href="#debugging-deadlocks" id="debugging-deadlocks">Debugging Deadlocks</a></h2>
<p>Occasionally locking changes in the core may result in deadlocks, which should hopefully be detected by the test suite. To assist in debugging these, the <code>SIGTERM</code> handler changes for the <code>test</code> build tag, causing the robot to perform a full stack dump and panic. Note that if an actual robot deadlocks, it should still accept an <code>abort</code> command from an administrator, which will trigger the same behavior.</p>
<p>If <code>make test</code> hangs, you can trigger a stack dump with <code>&lt;ctrl-c&gt;</code>; here's an example where updated locking of the <code>botContext</code> struct introduced a deadlock in the <code>reload</code> command:</p>
<pre><code class="language-shell">$ make test
...
=== RUN   TestReload
# Test hung here, &lt;ctrl-c&gt;
goroutine 631 [running]:
github.com/lnxjedi/gopherbot/bot.sigHandle(0xc0000a1f20)
        /home/davidparsley/git/gopherbot/bot/signal_testing.go:24 +0x243
created by github.com/lnxjedi/gopherbot/bot.run
        /home/davidparsley/git/gopherbot/bot/bot_process.go:310 +0x3e4
...
goroutine 590 [semacquire]:
sync.runtime_SemacquireMutex(0xc000358504, 0x900000000, 0x1)
        /usr/local/go/src/runtime/sema.go:71 +0x47
sync.(*Mutex).lockSlow(0xc000358500)
        /usr/local/go/src/sync/mutex.go:138 +0x1c1
sync.(*Mutex).Lock(0xc000358500)
        /usr/local/go/src/sync/mutex.go:81 +0x7d
github.com/lnxjedi/gopherbot/bot.Robot.getLockedContext(0xc00016e540, 0x81, 0x0)
        /home/davidparsley/git/gopherbot/bot/robot.go:25 +0x4e
github.com/lnxjedi/gopherbot/bot.Robot.Reply(0xc00016e540, 0x81, 0xbf0ee6, 0x23, 0x0, 0x0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/robot_connector_methods.go:212 +0x121
github.com/lnxjedi/gopherbot/bot.admin(0xce2020, 0xc0001ff930, 0xc0000b6320, 0x6, 0xc0001fedb0, 0x0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/builtins.go:345 +0x16b2
github.com/lnxjedi/gopherbot/bot.(*botContext).callTaskThread(0xc000358500, 0xc0003df6e0, 0xb0ef20, 0xc00012a180, 0xc0000b6320, 0x6, 0xc0001fedb0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/calltask.go:138 +0xb64
created by github.com/lnxjedi/gopherbot/bot.(*botContext).callTask
        /home/davidparsley/git/gopherbot/bot/calltask.go:75 +0xe8
...
panic: Tests terminated by signal terminated

goroutine 631 [running]:
github.com/lnxjedi/gopherbot/bot.sigHandle(0xc0000a1f20)
        /home/davidparsley/git/gopherbot/bot/signal_testing.go:27 +0x37a
created by github.com/lnxjedi/gopherbot/bot.run
        /home/davidparsley/git/gopherbot/bot/bot_process.go:310 +0x3e4
FAIL    github.com/lnxjedi/gopherbot/test       58.197s
FAIL
Makefile:52: recipe for target 'test' failed
make: *** [test] Error 1
</code></pre>
<p>In this case the lock on the <code>botContext</code> was first aquired at the top of the admin <code>reload</code> built-in command, and then hung later when trying to acquire the lock in the robot <code>Reply</code> method.</p>
<h1><a class="header" href="#coding-with-gitpod" id="coding-with-gitpod">Coding with Gitpod</a></h1>
<h1><a class="header" href="#important-structs-and-interfaces" id="important-structs-and-interfaces">Important Structs and Interfaces</a></h1>
<h2><a class="header" href="#the-robot-package" id="the-robot-package">The <code>robot</code> package</a></h2>
<p>The <code>robot</code> package defines structs and interfaces for <strong>Go</strong> tasks, plugins and jobs.</p>
<h3><a class="header" href="#the-robot-interface" id="the-robot-interface">The <code>Robot</code> interface</a></h3>
<p><code>Robot</code> defines the methods available to a <strong>Go</strong> task, plugin or job. Whenever the engine calls a handler for one of these, the first argument to the handler is always an object that implements the <code>Robot</code> interface. Internally (in the <code>bot</code> package), this is a <code>bot.Robot</code> struct, with methods that implement the <code>robot.Robot</code> interface.</p>
<h3><a class="header" href="#the-message-struct" id="the-message-struct">The <code>Message</code> struct</a></h3>
<p>The <code>GetMessage()</code> method on the <code>Robot</code> will return a <code>robot.Message</code>, which contains information about the user and channel, as well as a pointer to a copy of the original incoming data structure from the external connector. The complete definition is available from <a href="https://godoc.org/github.com/lnxjedi/robot#Message">godoc.org</a>.</p>
<h2><a class="header" href="#the-bot-package" id="the-bot-package">The <code>bot</code> package</a></h2>
<p>The <code>bot</code> package contains all the logic for a running robot.</p>
<h3><a class="header" href="#pipelines" id="pipelines">Pipelines</a></h3>
<p>Any time <strong>Gopherbot</strong> runs a task, plugin or job, it is part of a pipeline (which may consist only of a single job or plugin executing). The data structures for representing a pipeline are the <code>worker</code> and the <code>pipeContext</code>.</p>
<h3><a class="header" href="#workers" id="workers">Workers</a></h3>
<p>The <code>worker</code> struct represents a thread of execution. The worker contains all the invariant information about how it was created, whether from an incoming message, a scheduled job, or a job spawn from another worker. Workers are created for every incoming message, regardless of whether a pipeline is ever started. The worker includes a <code>context</code> pointer that is populated when <code>startPipeline(...)</code> is called.</p>
<h3><a class="header" href="#pipe-context" id="pipe-context">Pipe Context</a></h3>
<p>Whenever a pipeline is started, the <code>context</code> member of the <code>worker</code> struct is populated with a <code>pipeContext</code> (by <code>bot.registerActive</code>), to keep state for the pipeline. At this time four bytes of entropy are consumed for the <code>GOPHER_CALLER_ID</code> environment variable, to be passed to external scripts that run in the pipeline. This allows <code>bot/http.go</code> to look up the correct robot on each external script method call. The <code>pipeContext</code> contains a <code>sync.Mutex</code> member for locking, as it can be changed in different threads of execution. Note, however, that a well written task, plugin or job is not multi-threaded, and under normal circumstances all access to the <code>pipeContext</code> <em>should</em> be serialized.</p>
<h3><a class="header" href="#robots" id="robots">Robots</a></h3>
<p>The <code>bot.Robot</code> struct is created any time a task, plugin or job is run, and contains a pointer to the <code>robot.Message</code>, a pointer to the <code>bot.worker</code>, and a snapshot of the current <code>pipeContext</code> when <code>w.makeRobot</code> was called.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
