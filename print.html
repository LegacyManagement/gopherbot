<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gopherbot DevOps Chatbot</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="Title.html">Title</a></li><li class="expanded affix "><a href="Foreward.html">Foreward</a></li><li class="expanded affix "><a href="Introduction.html">Introduction</a></li><li class="expanded affix "><a href="Terminology.html">Terminology</a></li><li class="expanded "><a href="Installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><ol class="section"><li class="expanded "><a href="InstallOverview.html"><strong aria-hidden="true">1.1.</strong> Installation Overview</a></li><li class="expanded "><a href="DockerInstall.html"><strong aria-hidden="true">1.2.</strong> Docker Install</a></li></ol></li><li class="expanded "><a href="Upgrading.html"><strong aria-hidden="true">2.</strong> Upgrading from Version 1</a></li><li><ol class="section"><li class="expanded "><a href="upgrade/BotInfo.html"><strong aria-hidden="true">2.1.</strong> Required Bot Info</a></li><li class="expanded "><a href="upgrade/External-Plugin.html"><strong aria-hidden="true">2.2.</strong> External Plugin Configuration</a></li><li class="expanded "><a href="upgrade/Custom-Dir.html"><strong aria-hidden="true">2.3.</strong> Custom Configuration Directory</a></li><li class="expanded "><a href="upgrade/Encryption.html"><strong aria-hidden="true">2.4.</strong> Early Encryption Initialization</a></li></ol></li><li class="expanded "><a href="config/file.html"><strong aria-hidden="true">3.</strong> Configuration File Loading</a></li><li class="expanded "><a href="usage/admin.html"><strong aria-hidden="true">4.</strong> Administrator Commands</a></li><li class="expanded "><a href="usage/cli.html"><strong aria-hidden="true">5.</strong> Command-Line Use</a></li><li class="expanded "><a href="api/API-Introduction.html"><strong aria-hidden="true">6.</strong> Gopherbot API</a></li><li><ol class="section"><li class="expanded "><a href="api/Languages.html"><strong aria-hidden="true">6.1.</strong> Language Templates</a></li><li class="expanded "><a href="api/Attribute-Retrieval-API.html"><strong aria-hidden="true">6.2.</strong> Attribute Retrieval</a></li><li class="expanded "><a href="api/Brain-API.html"><strong aria-hidden="true">6.3.</strong> Brain Methods</a></li><li class="expanded "><a href="api/Message-Sending-API.html"><strong aria-hidden="true">6.4.</strong> Message Sending</a></li><li class="expanded "><a href="api/Pipeline-API.html"><strong aria-hidden="true">6.5.</strong> Pipeline Construction</a></li><li class="expanded "><a href="api/Response-Request-API.html"><strong aria-hidden="true">6.6.</strong> Requesting Responses</a></li><li class="expanded "><a href="api/Utility-API.html"><strong aria-hidden="true">6.7.</strong> Utility</a></li></ol></li><li class="expanded "><a href="Modules.html"><strong aria-hidden="true">7.</strong> Module Support</a></li><li class="expanded "><a href="pipelines/integrations.html"><strong aria-hidden="true">8.</strong> Tool Integrations</a></li><li><ol class="section"><li class="expanded "><a href="pipelines/ssh.html"><strong aria-hidden="true">8.1.</strong> Integrating with SSH</a></li></ol></li><li class="expanded "><a href="GopherDev.html"><strong aria-hidden="true">9.</strong> Working on Gopherbot</a></li><li><ol class="section"><li class="expanded "><a href="botdev/DevelRobot.html"><strong aria-hidden="true">9.1.</strong> Development Robot</a></li><li class="expanded "><a href="botdev/IntegrationTests.html"><strong aria-hidden="true">9.2.</strong> Integration Tests</a></li><li class="expanded "><a href="botdev/Gitpod.html"><strong aria-hidden="true">9.3.</strong> Coding with Gitpod</a></li><li class="expanded "><a href="botdev/StructsInterfaces.html"><strong aria-hidden="true">9.4.</strong> Important Structs and Interfaces</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Gopherbot DevOps Chatbot</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#gopherbotbrdevops-chatbot" id="gopherbotbrdevops-chatbot">Gopherbot</br>DevOps Chatbot</a></h1>
<p><img src="gopherbot.png" alt="Gophers+bot by Renee French, cropped, cc3.0" /></p>
<p>By David Parsley, <a href="mailto:parsley@linuxjedi.org">parsley@linuxjedi.org</a></p>
<p><strong>NOTE: This manual is a work in progress; currently incomplete and partly outdated. This note will be removed for the 2.0 release - for now YMMV.</strong></p>
<p>Gophers + Robot by Renee French (cropped) licensed under <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons License 3.0</a></p>
<p>My work with ChatOps began with Hubot around 2012 when I was working as an systems engineer for a small hosting provider. The owner had sent me a link to Hubot, asking me to have a look. I took to the concept immediately, and started automating all kinds of tasks that our support team could easily access from our team chat. Soon they were using our robot to troubleshoot email routing and DNS issues, migrate mailboxes, and build new cPanel server instances.</p>
<p>Not being a very talented (or motivated) Javascript/NodeJS programmer, my Hubot commands invariably followed the same pattern: write it in Javascript if it was <em>trivially</em> easy  to do so, otherwise shell out to bash and return the results. This was productive and gave results, but it was ugly and limited in functionality.</p>
<p>When I began teaching myself Go, I needed a good project to learn with. After my experience with Hubot, I decided to write a robot that was more approachable for Systems and DevOps engineers like myself - tasked with providing functionality most easily accessible from e.g. bash or python scripts. Towards that end, Gopherbot's design:</p>
<ul>
<li>Is CGI-like in operation: the compiled server process spawns scripts which can then use a simple API for interacting with the user / chat service</li>
<li>Supports any number of scripting languages by using a simple json-over-http localhost interface</li>
<li>Uses a multi-process design with method calls that block</li>
</ul>
<p>Ultimately, Gopherbot gives me a strong alternative to writing Yet Another Web Application to deliver some kind of reporting, security, or management functionality to managers and technical users. It's a good meet-in-the-middle solution that's nearly as easy to use as a web application, with some added benefits:</p>
<ul>
<li>The chat application gives you a single pane of glass for access to a wide range of functionality</li>
<li>The shared-view nature of channels gives an added measure of security thanks to visibility, and also a simple means of training users to interact with a given application</li>
<li>Like a CGI, applications can focus on functionality, with security and access control being configured in the server process</li>
</ul>
<p>It is my hope that this design will appeal to other engineers like myself, and that somewhere, somebody will exclaim &quot;Wait, what? I can write chat bot plugins <em><strong>in BASH</strong></em>?!?&quot;</p>
<p>David Parsley, March 2017 / September 2019</p>
<pre><code class="language-bash">#!/bin/bash

# echo.sh - trivial shell plugin example for Gopherbot

# START Boilerplate
[ -z &quot;$GOPHER_INSTALLDIR&quot; ] &amp;&amp; { echo &quot;GOPHER_INSTALLDIR not set&quot; &gt;&amp;2; exit 1; }
source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

command=$1
shift
# END Boilerplate

configure(){
	cat &lt;&lt;&quot;EOF&quot;
---
Help:
- Keywords: [ &quot;repeat&quot; ]
  Helptext: [ &quot;(bot), repeat (me) - prompt for and trivially repeat a phrase&quot; ]
CommandMatchers:
- Command: &quot;repeat&quot;
  Regex: '(?i:repeat( me)?)'
EOF
}

case &quot;$command&quot; in
# NOTE: only &quot;configure&quot; should print anything to stdout
	&quot;configure&quot;)
		configure
		;;
	&quot;repeat&quot;)
		REPEAT=$(PromptForReply SimpleString &quot;What do you want me to repeat?&quot;)
		RETVAL=$?
		if [ $RETVAL -ne $GBRET_Ok ]
		then
			Reply &quot;Sorry, I had a problem getting your reply: $RETVAL&quot;
		else
			Reply &quot;$REPEAT&quot;
		fi
		;;
esac
</code></pre>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p><strong>Gopherbot</strong> DevOps Chatbot is a tool for teams of developers, operators, infrastructure engineers and support personnel - primarily for those that are already using Slack or another team chat platform for day-to-day communication. It belongs to and integrates well with a larger family of tools including <em>Ansible</em>, <em>git</em> and <em>ssh</em>, and is able to perform many tasks similar to <em>Jenkins</em> or <em>TravisCI</em>; all of this functionality is made available to your team via the chat platform you're already using.</p>
<p>To help give you an idea of the kinds of tasks you can accomplish, here are a few of the things my teams have done with <strong>Gopherbot</strong> over the years:</p>
<ul>
<li>Generating and destroying <a href="https://aws.amazon.com">AWS</a> instances on demand</li>
<li>Running software build, test and deploy pipelines, triggered by git service integration with team chat</li>
<li>Updating service status on the department website</li>
<li>Allowing support personnel to search and query user attributes</li>
<li>Running scheduled backups to gather artifacts over <code>ssh</code> and publish them to an artifact service</li>
<li>Occasionally - generating silly memes</li>
</ul>
<p>The primary strengths of <strong>Gopherbot</strong> stem from it's simplicity and flexibility. It installs and bootstraps readily on a VM or in a container with just a few environment variables, and can be run behind a firewall where it can perform tasks like rebooting server hardware over IPMI. Simple command plugins can be written in <code>bash</code> or <code>python</code>, with easy to use encrypted secrets for accomplishing privileged tasks. Like any user, the robot can also have it's own (encrypted, naturally) ssh key for performing remote work and interfacing with <em>git</em> services.</p>
<p>The philosophy underlying <strong>Gopherbot</strong> is the idea of solving the most problems with the smallest set of general purpose tools, accomplishing a wide variety of tasks reasonably well. It's true that <strong>Gopherbot</strong> doesn't do CI/CD to the level of, say, <em>Jenkins</em> - but it's amazing how productive I am with it. Perhaps the best example of it's flexibility can be seen in the CI/CD pipeline for <strong>Gopherbot</strong> itself; start reading with <code>pipeline.sh</code> in <a href="https://github.com/lnxjedi/gopherbot/tree/master/.gopherci">the <code>.gopherci</code> directory</a>.</p>
<p>The major design goals for <strong>Gopherbot</strong> are reliability and portability, leaning heavily on &quot;configuration as code&quot;. Ideally, custom add-on plugins and jobs that work for a robot instance in <a href="https://slack.com">Slack</a> should work just as well if your team moves, say, to <a href="https://rocket.chat">Rocket.Chat</a>. This goal ends up being a trade-off with supporting specialized features of a given platform, though the <strong>Gopherbot</strong> API enables platform-specific customizations if desired.</p>
<p>Secondary but important design goals are configurability and security. Individual commands can be constrained to a subset of channels and/or users, requiring external authorization or elevation plugins, and administrators can customize help and command matching patterns for stock plugins. <strong>Gopherbot</strong> has been built with security considerations in mind from the start; employing strong encryption, privilege separation, and a host of other measures to make your robot a difficult target.</p>
<p>Version 2 for the most part assumes that your robot will employ encryption and get it's configuration from a <em>git</em> repository. Other deployments are possible, but not well documented. This manual will focus on working with <strong>Gopherbot</strong> instances whose configuration is stored on <a href="https://github.com">Github</a>, but other <em>git</em> services are easy to use, as well.</p>
<p>That's it for the &quot;marketing&quot; portion of this manual - by now you should have an idea whether <strong>Gopherbot</strong> would be a good addition to your DevOps tool set.</p>
<h1><a class="header" href="#terminology" id="terminology">Terminology</a></h1>
<p>This section is most important for referring back to as you read the documentation, to disambiguate terms.</p>
<p>(It's also for me, to help maintain some consistency)</p>
<ul>
<li><strong>Gopherbot</strong> - The installed software archive that comprises the <strong>Gopherbot DevOps Chatbot</strong></li>
<li><strong>robot</strong> - A configured instance of <strong>Gopherbot</strong> available in your team chat; possibly also a reference to a particular robot's configuration repository</li>
<li><strong>plugin</strong> (or <strong>command plugin</strong>) - A piece of code that provides new commands or code for authorization and/or elevation</li>
<li><strong>authorizer</strong> - special plugin command used to determine whether a given user is authorized for a given command, normally checking some kind of group membership</li>
<li><strong>elevator</strong> - special plugin command providing additional verification of user identity; this can be as simple as a totp token or <a href="https://duo.com">Duo</a> two-factor, or as complex as prompting another user before allowing a command to proceed</li>
<li><strong>job</strong> - jobs are pieces of code that typically use the pipeline API for creating pipelines to perform complex scheduled tasks such as backups and monitoring, or for software builds that may be triggered by hosted git service integrations with your chat platform</li>
<li><strong>task</strong> - tasks are small pieces of code that generally form the parts of a pipeline, such as initializing (and tearing down) the <code>ssh-agent</code>, running pipeline scripts, or sending notifications; the task is also the base object for jobs and plugins, so &quot;task&quot; may refer to any entry in <code>ExternalPlugins</code>, <code>ExternalTasks</code>, <code>ExternalJobs</code>, etc. </li>
<li><strong>Robot</strong> - The object passed to user plugins, jobs and tasks; also the <strong>Go</strong> library for loadable modules</li>
</ul>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>The most basic install of <strong>Gopherbot</strong> consists of extracting the archive to <code>/opt/gopherbot</code>, creating a robot configuration repository, and running the <code>gopherbot</code> binary from the root of that directory. There are a number of other details covered in the <a href="InstallOverview.html">overview</a>, but that's the gist of it.</p>
<h1><a class="header" href="#installation-overview" id="installation-overview">Installation Overview</a></h1>
<p>Version 2 of <strong>Gopherbot</strong> introduced a new, unified and simplified install method for both host- and container- based installs. Whether creating an instance of a new robot, or running an existing robot in a new location, basic installation to a host consists of a few simple steps:</p>
<ol>
<li>Un-zip or un-tar the download archive in <code>/opt/gopherbot</code></li>
<li>Create a new empty directory for your robot; by convention <code>\&lt;name\&gt;-gopherbot</code>, e.g. <code>clu-gopherbot</code>
<ol>
<li>Optionally, create a symlink to the binary, e.g.: <code>cd clu-gopherbot; ln -s /opt/gopherbot/gopherbot .</code></li>
</ol>
</li>
<li>Run the gopherbot binary from the new directory: <code>/opt/gopherbot/gopherbot</code> or <code>./gopherbot</code></li>
</ol>
<h2><a class="header" href="#quick-start-with-docker" id="quick-start-with-docker">Quick Start with Docker</a></h2>
<p>If you've already got a Docker host and Slack team, this is the absolute fastest way to get your very own robot up and running for playing around with, though not recommended for production installs.</p>
<ol>
<li>Get a Slack token for your robot at https://&lt;your-team&gt;.slack.com/services/new/bot</li>
<li>Create the environment file <code>.env</code>, filling in your specific values (except for GOPHER_ADMIN, filled in later):</li>
</ol>
<pre><code class="language-env">GOPHER_ADMIN=
GOPHER_SLACK_TOKEN=xoxb-yourTokenHere
GOPHER_BOTNAME=nameOfYourBot
GOPHER_BOTFULLNAME=&quot;Optional Full Name&quot;
# A one-character alias for addressing the robot, e.g. \ping
# Other good values: ; ! *
GOPHER_ALIAS=\
</code></pre>
<ol start="3">
<li>Start your robot with <code>docker run --env .env --name &lt;nameOfYourBot&gt; lnxjedi/gopherbot</code>, for example:</li>
</ol>
<pre><code class="language-shell">$ docker run --env-file .env --name frodo lnxjedi/gopherbot
</code></pre>
<p>If all goes well, your terminal window will start filling up with <strong>Gopherbot</strong> debug logs, and your robot will connect to your Slack team. Now you can invite your robot user to a channel and try out a few commands. Assuming you used <code>\</code> for the alias, and <code>frodo</code> for the robot's name, you can try:</p>
<ul>
<li><code>\ping</code></li>
<li><code>frodo, info</code></li>
<li><code>help</code> - for general help</li>
<li><code>\help</code> - for help on available commands</li>
<li><code>\whoami</code></li>
</ul>
<h3><a class="header" href="#adding-an-administrator" id="adding-an-administrator">Adding an Administrator</a></h3>
<p>These instructions assume you kept the default <code>\</code> for the robot's alias.</p>
<ol>
<li>Use the <code>\whoami</code> command to determine your actual Slack username, which frequently differs from the display name you see in channels</li>
<li>Press &lt;ctrl-c&gt; to stop your container, then remove it:</li>
</ol>
<pre><code class="language-shell">$ docker container rm frodo
</code></pre>
<ol start="3">
<li>Edit the <code>.env</code> file, adding your Slack user name for <code>GOPHER_ADMIN</code></li>
<li>Run the robot again as in step 3 above</li>
</ol>
<p>Now you can try out some more commands:</p>
<ul>
<li><code>\reload</code></li>
<li><code>\info</code> (more verbose output for admins)</li>
</ul>
<p>Additionally, there are a few commands you can try in a DM (private message) to the robot:</p>
<ul>
<li><code>list plugins</code></li>
<li><code>debug task memes</code></li>
<li><code>quit</code> - the container will exit and need to be re-started</li>
<li><code>help</code> - the list of commands will include all the administrator commands</li>
</ul>
<p>TODO: More documentation, including production installs.</p>
<h1><a class="header" href="#upgrading-from-version-1" id="upgrading-from-version-1">Upgrading from Version 1</a></h1>
<p>The following sections detail the required and optional changes for upgrading a robot from version 1 to version 2. Over the course of developing version 2, there were several intermediary states for different configuration options that are not described here. If you need information on upgrading from any of these intermediary states, please <a href="https://github.com/lnxjedi/gopherbot/issues/new">open an issue</a>.</p>
<h1><a class="header" href="#required-bot-info" id="required-bot-info">Required Bot Info</a></h1>
<p>Earlier versions of <strong>Gopherbot</strong> expected to get info about the robot - name, handle, etc. - from the protocol connector; however, that can't be counted on. For your robot to respond to a command like <code>floyd, ping</code>, it will need a minimal <code>BotInfo</code> section in <code>gopherbot.yaml</code>:</p>
<pre><code class="language-yaml">BotInfo:
  UserName: floyd
</code></pre>
<p>To provide other information about the robot to the <code>GetBotAttribute()</code> method, you might want to fill out the entire structure:</p>
<pre><code class="language-yaml">BotInfo:
  UserName: floyd
  Email: floyd@linuxjedi.org
  FullName: Floyd Gopherbot
  FirstName: Floyd
  LastName: Gopherbot
</code></pre>
<p>The robot's single-character <code>Alias</code> is still specified by itself, as before; e.g. <code>Alias: &quot;;&quot;</code>.</p>
<h1><a class="header" href="#external-plugin-configuration" id="external-plugin-configuration">External Plugin Configuration</a></h1>
<p>ExternalPlugins were formerly a list, but are now a hash, so:</p>
<pre><code class="language-yaml">ExternalPlugins:
- Name: chuck
  Path: plugins/chuck.rb
</code></pre>
<p>becomes:</p>
<pre><code class="language-yaml">ExternalPlugins:
  &quot;chuck&quot;:
    Path: plugins/chuck.rb
</code></pre>
<p>This allows all default configuration in the installation to be flexibly modified for a particular robot, using the new configuration merging.</p>
<h1><a class="header" href="#custom-configuration-directory" id="custom-configuration-directory">Custom Configuration Directory</a></h1>
<p>Version 2's configuration layout is heavily oriented towards an all-in-one robot directory, <code>$GOPHER_HOME</code>, with brain, job logs, workspaces, and others as subdirectories. It standardizes the location of the custom configuration directory (repository) to <code>$(pwd)/custom</code> (a.k.a. <code>$GOPHER_HOME/custom</code>). While setting the location with <code>-c &lt;dir&gt;</code> or via the <code>GOPHER_CONFIGDIR</code> environment variable are still supported, existing installations should locate custom configuration in a directory named <code>custom/</code>, with the robot started from the parent directory. See the <a href="upgrade/../InstallOverview.html">Installation Overview</a> for more information on the standard directory structure.</p>
<p>If your configuration is already in a repository, and the previous updates have already been made, then you can probably just run <code>/opt/gopherbot/gopherbot</code> from an empty directory and use the new setup plugin to bootstrap your robot.</p>
<h2><a class="header" href="#early-encryption-initialization" id="early-encryption-initialization">Early Encryption Initialization</a></h2>
<p><strong>Gopherbot</strong> uses two separate keys for encrypting and decrypting secret data:</p>
<ul>
<li>The start-up key, normally 32 printable <code>ASCII</code> characters, used only for decrypting the binary, 32-byte random encryption key</li>
<li>The permanent runtime encryption key, 32 random bytes generated on the first run </li>
</ul>
<p>In version 1 and early snapshots of version 2, the runtime key was stored in the brain, and encryption was only initialized after the robot's brain provider and protocol connector. Secrets for these had to be provided in the environment, or unencrypted in <code>gopherbot.yaml</code>. Version 2 addresses this by storing the binary encrypted runtime key in a <code>base64</code> encoded file, <code>custom/binary-encrypted-key</code>. This allows storing encrypted values for e.g. the <em>slack token</em> or <em>AWS credentials</em> in <code>gopherbot.yaml</code>, and only needing to provide the start-up <code>GOPHER_ENCRYPTION_KEY</code> in the environment, or in an external environment file - <code>$GOPHER_HOME/.env</code> or <code>$GOPHER_HOME/private/environment</code>.</p>
<p>For a robot instance with a file-backed brain, the following command can be used to generate the version 2 key file:</p>
<pre><code class="language-bash">$ cat /path/to/brain/bot:encryptionKey | base64 -w 0 &gt; /path/to/custom/binary-encrypted-key
</code></pre>
<p>This file can then be committed to the custom configuration repository.</p>
<h2><a class="header" href="#default-brain-encryption" id="default-brain-encryption">Default Brain Encryption</a></h2>
<p>In version 2, <strong>Gopherbot</strong> defaults to an encrypted brain, which requires a <code>GOPHER_ENCRYPTION_KEY</code> to be set. To run your robot without brain encryption, you need to explicitly turn it off in your custom <code>gopherbot.yaml</code>:</p>
<pre><code class="language-yaml">EncryptBrain: false
</code></pre>
<h1><a class="header" href="#configuration-file-loading" id="configuration-file-loading">Configuration File Loading</a></h1>
<p><strong>Gopherbot</strong> uses <strong>YAML</strong> for it's configuration files, and Go text templates for expanding the files it reads. Any time <strong>Gopherbot</strong> loads a configuration file, say <code>conf/gopherbot.yaml</code>, it first looks for the file in the installation directory, and loads and expands that file if found. Next it looks for the same file in the custom configuration directory; if found, it loads and expands that file, then recursively merges the two data structures:</p>
<ul>
<li>Map values merge and override</li>
<li>Array values are replaced</li>
</ul>
<p>To illustrate with an example, take the following two excerpts from <code>gopherbot.yaml</code>:</p>
<p>Default from the install archive:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: general
  Channels:
  - random
  - general
  StartUser: alice
</code></pre>
<p>Custom local configuration:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: jobs
  Channels:
  - jobs
  - general
</code></pre>
<p>The resulting configuration would be:</p>
<pre><code class="language-yaml">ProtocolConfig:
  StartChannel: jobs
  Channels:
  - jobs
  - general
  StartUser: alice
</code></pre>
<h2><a class="header" href="#template-expansion" id="template-expansion">Template Expansion</a></h2>
<p><strong>Gopherbot</strong> uses standard <a href="https://golang.org/pkg/text/template">Go text templates</a> for expanding the configuration files it reads. In addition to the stock syntactic elements, the following functions and methods are available:</p>
<h3><a class="header" href="#the-env-function" id="the-env-function">The <code>env</code> function</a></h3>
<pre><code>{{ env &quot;GOPHER_ALIAS&quot; }}
</code></pre>
<p>This would expand to the value of the <code>GOPHER_ALIAS</code> environment variable.</p>
<h3><a class="header" href="#the-default-function" id="the-default-function">The <code>default</code> function</a></h3>
<pre><code>{{ env &quot;GOPHER_ALIAS&quot; | default &quot;;&quot; }}
</code></pre>
<p>The <code>default</code> function takes two arguments, and returns the first argument if it's length is &gt; 0, the second argument otherwise. The example would expand to the value of the <code>GOPHER_ALIAS</code> environment variable if set, or <code>;</code> otherwise.</p>
<h2><a class="header" href="#the-decrypt-function" id="the-decrypt-function">The <code>decrypt</code> function</a></h2>
<pre><code>ProtocolConfig:
  SlackToken: xoxb-18000000000-470000000000-{{ decrypt &quot;xxxxx&quot; }}
</code></pre>
<p>To make it safe to store secret values in configuration, administrators can send a direct message to the robot requesting encryption, e.g.:</p>
<pre><code>c:(direct)/u:alice -&gt; encrypt MyLousyPassword
(dm:alice): RPzxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx+9rf==
</code></pre>
<p>The encrypted value can then be pasted in to the <code>decrypt</code> function. See the section on <em>encryption</em> for more information.</p>
<p><strong>NOTE:</strong> In the example, the common, low-entropy portion of a <em>slack</em> token is left as-is, and only the high-entropy portion of the token is encrypted, to prevent attacks where a portion of the encrypted value is known.</p>
<h2><a class="header" href="#the-include-method" id="the-include-method">The <code>.Include</code> method</a></h2>
<pre><code>{{ .Include &quot;terminal.yaml&quot; }}
</code></pre>
<p><code>.Include</code> is a <em>method</em> on the configuration file object, which is either an install file or a custom file. If the above example is present in the installed <code>conf/gopherbot.yaml</code>, it will include <em>only</em> the installed <code>conf/terminal.yaml</code>, if present, and ignore that file if it's also present in the custom directory.</p>
<p>Note that <code>.Include</code>'d files are also expanded as templates in the same manner.</p>
<h1><a class="header" href="#administrator-commands" id="administrator-commands">Administrator Commands</a></h1>
<h1><a class="header" href="#command-line-use" id="command-line-use">Command-Line Use</a></h1>
<h2><a class="header" href="#api-for-plugins-jobs-and-tasks" id="api-for-plugins-jobs-and-tasks">API for Plugins, Jobs and Tasks</a></h2>
<p><strong>Gopherbot</strong> provides an object-oriented API for writing your own command plugins, jobs and tasks. With the exception of the <code>bash</code> library, API calls are accessed from methods on a <strong>robot</strong> object. The following sections detail the usage of the various methods.</p>
<p>Gopherbot's functionality can be easily extended by writing plugins in one of several different languages. A single plugin can provide:</p>
<ul>
<li>One or more new commands the robot will understand</li>
<li>Elevation logic for providing extra assurance of user identity</li>
<li>Authorization logic for determining a user's rights to issue various commands</li>
</ul>
<p>This article deals mainly with writing plugins in one of the scripting languages supported by Gopherbot, the most popular means for writing new command plugins. For writing native compiled-in plugins in Go, see <code>gopherbot/main.go</code> and the sample plugins in <code>goplugins/</code>. API documentation for Robot methods is available at:</p>
<p>https://godoc.org/github.com/lnxjedi/gopherbot/bot#Robot</p>
<p>Note that the script plugin API is implemented on top of the native Go API, so that document may also be of use for scripting plugin authors. The file <code>bot/http.go</code>, and the scripting libraries in <code>lib/</code> will illuminate the mapping from the script APIs to the native Go API.</p>
<h1><a class="header" href="#table-of-contents" id="table-of-contents">Table of Contents</a></h1>
<ul>
<li><a href="api/Languages.html#plugin-loading-and-precedence">Plugin Loading and Precedence</a></li>
<li><a href="api/Languages.html#default-configuration">Default Configuration</a></li>
<li><a href="api/Languages.html#calling-convention">Calling Convention</a>
<ul>
<li><a href="api/Languages.html#environment-variables">Environment Variables</a></li>
<li><a href="api/Languages.html#reserved-commands">Reserved Commands</a></li>
</ul>
</li>
<li><a href="api/Languages.html#plugin-types-and-calling-events">Plugin Types and Calling Events</a>
<ul>
<li><a href="api/Languages.html#command-plugins">Command Plugins</a></li>
<li><a href="api/Languages.html#authorization-plugins">Authorization Plugins</a></li>
<li><a href="api/Languages.html#elevation-plugins">Elevation Plugins</a></li>
</ul>
</li>
<li><a href="api/Languages.html#using-the-terminal-connector">Using the Terminal Connector</a></li>
<li><a href="api/Languages.html#plugin-debugging">Plugin Debugging</a>
<ul>
<li><a href="api/Languages.html#debug-plugin-command">Debug Plugin Command</a></li>
<li><a href="api/Languages.html#dump-plugin-command">Dump Plugin Command</a></li>
</ul>
</li>
<li><a href="api/Languages.html#getting-started">Getting Started</a>
<ul>
<li><a href="api/Languages.html#starting-from-a-sample-plugin">Starting from a Sample Plugin</a></li>
<li><a href="api/Languages.html#using-boilerplate-code">Using Boilerplate Code</a>
<ul>
<li><a href="api/Languages.html#bash-boilerplate">Bash Boilerplate</a></li>
<li><a href="api/Languages.html#powershell-boilerplate">PowerShell Boilerplate</a></li>
<li><a href="api/Languages.html#python-boilerplate">Python Boilerplate</a></li>
<li><a href="api/Languages.html#ruby-boilerplate">Ruby Boilerplate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="api/Languages.html#the-plugin-api">The Plugin API</a></li>
</ul>
<h1><a class="header" href="#plugin-loading-and-precedence" id="plugin-loading-and-precedence">Plugin Loading and Precedence</a></h1>
<p>Gopherbot ships with a number of external script plugins in the <code>install</code> directory. These can be overridden by placing a plugin with the same filename in the optional configuration directory.</p>
<h1><a class="header" href="#default-configuration" id="default-configuration">Default Configuration</a></h1>
<p>Plugin configuration is fully documented in the <a href="api/Configuration.html">configuration</a> article; you should be familiar with that document before beginning to write your own plugins.</p>
<p>On start-up and during a reload, the robot will run each external script plugin with an argument of <code>configure</code>. The plugin should respond by writing the plugin default configuration to standard out and exiting with exit code 0. When responding to <code>configure</code>, the plugin shouldn't initialize a robot object or make any API calls, as <code>configure</code> is called without setting robot environment variables.</p>
<h1><a class="header" href="#calling-convention" id="calling-convention">Calling Convention</a></h1>
<p>The robot calls external plugins by creating a goroutine and exec'ing the external script with a set of environment variables. The external script uses the appropriate library for the scripting language to create a robot object from the environment. The script then examines it's command-line arguments to determine the type of action to take (normally a command followed by arguments to the command), and uses the library to make JSON-over-http calls for executing and returning results from methods. Depending on how the plugin is used, different kinds of events can cause external plugins to be called with a variety of commands and arguments. The most common means of calling an external plugin is for one of it's commands to be matched, or by matching a pattern in an ambient message (one not specifically directed to the robot).</p>
<p>There are two sources of information for an external plugin being called:</p>
<ul>
<li>Environment Variables - these should generally only be referenced by the scripting library</li>
<li>Command Line Arguments - these should be used by the plugin to determine what to do</li>
</ul>
<h2><a class="header" href="#environment-variables" id="environment-variables">Environment Variables</a></h2>
<p>Gopherbot sets two primary environment variables of use to the plugin developer:</p>
<ul>
<li>GOPHER_CONFIGDIR - the directory where Gopherbot looks for it's configuration</li>
<li>GOPHER_INSTALLDIR - the directory where the Gopherbot executable resides</li>
</ul>
<p>In addition, the following two environment variables are set for every script plugin:</p>
<ul>
<li>GOPHER_USER - the username of the user who spoke to the robot</li>
<li>GOPHER_CHANNEL - the channel the user spoke in (empty string indicates a direct message)</li>
</ul>
<h2><a class="header" href="#reserved-commands" id="reserved-commands">Reserved Commands</a></h2>
<p>The first argument to a plugin script is the <strong>command</strong>. In addition to the <code>configure</code> command, which instructs a plugin to dump it's default configuration to standard out, the following commands are reserved:</p>
<ul>
<li><code>init</code> - After starting the connector and on reload, the robot will call external plugins with a command argument of <code>init</code>. Since all environment variables for the robot are set at that point, it would be possible to e.g. save a robot data structure that could be loaded and used in a cron job.</li>
<li><code>authorize</code> - The plugin should check authorization for the user and return <code>Success</code> or <code>Fail</code></li>
<li><code>elevate</code> - The plugin should perform additional authentication for the user and return <code>Success</code> or <code>Fail</code></li>
<li><code>event</code> - This command is reserved for future use with e.g. user presence change &amp; channel join/leave events</li>
<li><code>catchall</code> - Plugins with <code>CatchAll: true</code> will be called for commands directed at the robot that don't match a command plugin. Normally these are handled by the compiled-in <code>help</code> plugin, but administrators could override that setting and provide their own plugin with <code>CatchAll: true</code>. Note that having multiple such plugins is probably a bad idea.</li>
</ul>
<h1><a class="header" href="#plugin-types-and-calling-events" id="plugin-types-and-calling-events">Plugin Types and Calling Events</a></h1>
<p>There are (currently) three different kinds of external plugin:</p>
<ul>
<li>Command / Message Plugins - these are called by the robot in respond to messages the user sends</li>
<li>Authorization Plugins - these plugins encapsulate the logic for authorizing specific users to use specific commands, and are called by the robot during authorization processing</li>
<li>Elevation Plugins - these plugins perform some variety of multi-factor authentication for higher assurance of user identity, and are called by the robot during elevation processing</li>
</ul>
<h2><a class="header" href="#command-plugins" id="command-plugins">Command Plugins</a></h2>
<p>A command plugin's configuration specifies <code>CommandMatchers</code> and <code>MessageMatchers</code> that associate regular expressions with plugin commands:</p>
<pre><code class="language-yaml">MessageMatchers:
- Command: help
  Regex: '^(?i:help)$'
CommandMatchers:
- Regex: (?i:remember ([-\w .,!?:\/]+))
  Command: remember
  Contexts: [ &quot;item&quot; ]
</code></pre>
<p>Whenever a <code>CommandMatcher</code> regex matches a command given to the robot, or a <code>MessageMatcher</code> matches an ambient message, the robot calls the plugin script with the first argument being the matched <code>Command</code>, and subsequent arguments corresponding to the regex capture groups (which may in some cases be an empty string). Command plugins should normally exit with status 0 (bot.Normal), or non-zero for unusual error conditions that may require an administrator to investigate. The robot will notify the user whenever a command plugin exits non-zero, or when it emits output to STDERR.</p>
<h2><a class="header" href="#authorization-plugins" id="authorization-plugins">Authorization Plugins</a></h2>
<p>To separate command logic from user authorization logic, Gopherbot supports the concept of an <strong>authorization plugin</strong>. The main <code>gopherbot.yaml</code> can define a specific plugin as the <code>DefaultAuthorizer</code>, and individual plugins can be configured to override this value by specifying their own <code>Authorizer</code> plugin. If a plugin lists any commands in it's <code>AuthorizedCommands</code> config item, or specifies <code>AuthorizeAllCommands: true</code>, then the robot will call the authorizer plugin with a command of <code>authorize</code>, followed by the following arguments:</p>
<ul>
<li>The name of the plugin for which authorization is being requested</li>
<li>The optional value of <code>AuthRequire</code>, which may be interpreted as a group or role</li>
<li>The plugin command being called followed by any arguments passed to the command</li>
</ul>
<p>Based on these values and the <code>User</code> and <code>Channel</code> values from the robot, the authorization plugin should evaluate whether a user/plugin is authorized for the given command and exit with one of:</p>
<ul>
<li>bot.Succeed (1) - authorized</li>
<li>bot.Fail (2) - not authorized</li>
<li>bot.MechanismFail (3) - a technical issue prevented the robot from determining authorization</li>
</ul>
<p>Note that exiting with <code>bot.Normal</code> (0) or other values will result in an error and failed authentication.</p>
<p>Additionally, authorization plugins may provide extra feedback to the user on <code>Fail</code> or <code>MechanismFail</code> so they can have the issue addressed, e.g. &quot;Authorization failed: user not a member of group 'foo'&quot;. In some cases, however, authorization plugins may not have a full Gopherbot API library; they could be written in C, and thus not be able to interact with the user.</p>
<h2><a class="header" href="#elevation-plugins" id="elevation-plugins">Elevation Plugins</a></h2>
<p>Elevation plugins provide the means to request additional authentication from the user for commands where higher assurance of identity is desired. The main <code>gopherbot.yaml</code> can specify an elevation plugin as the <code>DefaultElevator</code>, which can be overridden by a given plugin specifying an <code>Elevator</code>. When the plugin lists commands as <code>ElevatedCommands</code> or <code>ElevateImmediateCommands</code>, the robot will call the appropriate elevator plugin with a command of <code>elevate</code> and a first argument of <code>true</code> or <code>false</code> for <code>immediate</code>. The elevator plugin should interpret <code>immediate == true</code> to mean MFA is required every time; when <code>immediate != true</code>, successful elevation may persist for a configured timeout period.</p>
<p>Based on the result of the elevation determination, the plugin should have an exit status one of:</p>
<ul>
<li>bot.Succeed (1) - elevation succeeded</li>
<li>bot.Fail (2) - elevation failed</li>
<li>bot.MechanismFail (3) - a technical issue prevented the robot from processing the elevation request</li>
</ul>
<p>Note that exiting with <code>bot.Normal</code> (0) or other value will result in an error being logged and elevation failing.</p>
<p>Additionally, the elevation plugin may provide extra feedback to the user when elevation isn't successful to indicate the nature of the failure.</p>
<h1><a class="header" href="#using-the-terminal-connector" id="using-the-terminal-connector">Using the Terminal Connector</a></h1>
<p>Interacting with your bot in a chat app might not always be convenient or fast; to simplify
testing and plugin development, <strong>Gopherbot</strong> includes a terminal connector that emulates
a chat service with multiple users and channels, with a sample
configuration in the <code>cfg/term/</code> directory. You'll probably want to copy the directory and modify
it for your own use (mainly configuring the plugins you're developing), but it can be used
by using the <code>-c &lt;configpath&gt;</code> option:</p>
<pre><code>[gopherbot]$ ./gopherbot -c cfg/term/
2018/04/13 18:07:52 Initialized logging ...
2018/04/13 18:07:52 Starting up with config dir: cfg/term/, and install dir: /home/user/go/src/github.com/lnxjedi/gopherbot
2018/04/13 18:07:52 Debug: Loaded installed conf/gopherbot.yaml
2018/04/13 18:07:52 Debug: Loaded configured conf/gopherbot.yaml
Terminal connector running; Use '|C&lt;channel&gt;' to change channel, or '|U&lt;user&gt;' to change user
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; ;ping
general: @bob PONG
c:general/u:bob -&gt; |ualice
Changed current user to: alice
c:general/u:alice -&gt; |crandom
Changed current channel to: random
c:random/u:alice -&gt; ;quit
random: @alice Adios
[gopherbot]$
</code></pre>
<h1><a class="header" href="#plugin-debugging" id="plugin-debugging">Plugin Debugging</a></h1>
<p>The most common problem for plugin authors is the robot does nothing after sending it a message,
or the robot just says <code>Sorry, that didn't match any commands I know, ...</code>.</p>
<p>This can be due to a number of issues:</p>
<ul>
<li>The plugin didn't load because of various configuration problems</li>
<li>The robot isn't in the channel, and doesn't hear the message</li>
<li>The plugin isn't visible because of channel, user, or other restrictions</li>
<li>The user message doesn't match a regex for the plugin</li>
<li>The plugin runs, but does nothing</li>
</ul>
<p>To track down these issues easily, <strong>Gopherbot</strong> has the builtin administrator commands <code>debug plugin</code> and <code>dump plugin</code>. Make sure your username / handle is listed in the
<code>AdminUsers</code> list in <code>gopherbot.yaml</code> for your development environment.</p>
<h2><a class="header" href="#debug-plugin-command" id="debug-plugin-command">Debug Plugin Command</a></h2>
<p><strong>Gopherbot</strong> has a builtin command for plugin debugging that can help quickly pinpoint
most problems. Turning on plugin debugging will initiate a reload, then send debugging
information about a plugin in direct messages. If <code>verbose</code> is enabled, you will get debugging
information for every message you send, or every command sent to the robot by another user.
You can see an example of plugin debugging here with the terminal connector:</p>
<pre><code>[gopherbot]$ ./gopherbot
2018/04/18 15:43:01 Initialized logging ...
2018/04/18 15:43:01 Starting up with config dir: /home/user/.gopherbot, and install dir: /home/user/go/src/github.com/lnxjedi/gopherbot
2018/04/18 15:43:01 Debug: Loaded installed conf/gopherbot.yaml
2018/04/18 15:43:01 Debug: Loaded configured conf/gopherbot.yaml
Terminal connector running; Use '|C&lt;channel&gt;' to change channel, or '|U&lt;user&gt;' to change user
c:general/u:alice -&gt; ;ruby me!
general: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:general/u:alice -&gt; ;help debug
general: Command(s) matching keyword: debug
floyd, debug plugin &lt;pluginname&gt; (verbose) - turn on debugging for the named plugin, optionally verbose

floyd, stop debugging - turn off debugging
c:general/u:alice -&gt; ;debug plugin rubydemo
general: Debugging enabled for rubydemo (verbose: false)
c:general/u:alice -&gt; ;ruby me!
(dm:alice): 2018/04/18 03:43:15 DEBUG rubydemo: plugin is NOT visible to user alice in channel general; channel 'general' is not on the list of allowed channels: random
general: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:general/u:alice -&gt; |crandom
Changed current channel to: random
c:random/u:alice -&gt; ;ruby me to the max!
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: plugin is visible to user alice in channel random
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Checking 7 command matchers against message: &quot;ruby me to the max!&quot;
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:bashecho ([.;!\d\w-, ]+))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:ruby( me)?!?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:listen( to me)?!?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:remember(?: (slowly))? ([-\w .,!?:\/]+))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:recall ?([\d]+)?)
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:forget ([\d]{1,2}))
(dm:alice): 2018/04/18 03:43:44 DEBUG rubydemo: Not matched: (?i:check me)
random: @alice Sorry, that didn't match any commands I know, or may refer to a command that's not available in this channel; try 'floyd, help &lt;keyword&gt;'
c:random/u:alice -&gt; ;ruby me!
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: plugin is visible to user alice in channel random
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Checking 7 command matchers against message: &quot;ruby me!&quot;
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Not matched: (?i:bashecho ([.;!\d\w-, ]+))
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Matched command regex '(?i:ruby( me)?!?)', command: ruby
(dm:alice): 2018/04/18 03:43:49 DEBUG rubydemo: Running plugin with command 'ruby' and arguments: [ me]
random: Sure, Alice!
random: I'll ruby you, but not right now - I'll wait 'til you're least expecting it...
(dm:alice): 2018/04/18 03:43:51 DEBUG rubydemo: Plugin finished with return value: Normal
</code></pre>
<p><strong>NOTE:</strong> If your plugin is disabled with a mysterious <code>File not found</code> error, be sure you've got the
appropriate scripting language installed. If the first line in your plugin is e.g.:</p>
<pre><code>#!/usr/bin/ruby
</code></pre>
<p>... you'll get <code>File not found</code> if <code>/usr/bin/ruby</code> isn't present on the system.</p>
<h2><a class="header" href="#dump-plugin-command" id="dump-plugin-command">Dump Plugin Command</a></h2>
<p>To view a plugin's default or final configuration, you can use the <code>dump plugin</code> command:</p>
<pre><code>c:general/u:alice -&gt; ;help dump
general: Command(s) matching keyword: dump
floyd, dump plugin (default) &lt;plugname&gt; - dump the current or default configuration for the plugin (direct message only)

floyd, dump robot - dump the current configuration for the robot (direct message only)
c:general/u:alice -&gt; |c
Changed current channel to: direct message
c:(direct)/u:alice -&gt; dump plugin rubydemo
(dm:alice): AdminCommands: null
AllChannels: false
AllowDirect: true
AuthRequire: &quot;&quot;
AuthorizeAllCommands: false
AuthorizedCommands: null
Authorizer: &quot;&quot;
CatchAll: false
... (MUCH more)
</code></pre>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<h2><a class="header" href="#starting-from-a-sample-plugin" id="starting-from-a-sample-plugin">Starting from a Sample Plugin</a></h2>
<p>The simplest way for a new plugin author to get started is to:</p>
<ul>
<li>Disable the demo plugin for your chosen scripting language (if enabled) in <code>&lt;config dir&gt;/conf/gopherbot.yaml</code></li>
<li>Copy the demo plugin to <code>&lt;config dir&gt;/plugins/&lt;newname&gt;(.extension)</code></li>
<li>Enable your new plugin in <code>gopherbot.yaml</code> and give it a descriptive <code>Name</code></li>
</ul>
<h2><a class="header" href="#using-boilerplate-code" id="using-boilerplate-code">Using Boilerplate Code</a></h2>
<p>Each supported scripting language has a certain amount of &quot;boilerplate&quot; code required in every command plugin; generally, the boilerplate code is responsible for:</p>
<ul>
<li>Loading the appropriate version of the Gopherbot library from <code>$GOPHER_INSTALLDIR/lib</code></li>
<li>Defining and providing the default config</li>
<li>Instantiating a Robot object with a library call
Normally this is followed by some form of case / switch statement that performs different functions based on the contents of the first argument, a.k.a. the &quot;command&quot;.</li>
</ul>
<h3><a class="header" href="#bash-boilerplate" id="bash-boilerplate">Bash Boilerplate</a></h3>
<pre><code class="language-bash">#!/bin/bash -e

source $GOPHER_INSTALLDIR/lib/gopherbot_v1.sh

COMMAND=$1
shift

configure(){
  cat &lt;&lt;&quot;EOF&quot;
&lt;yaml config document&gt;
EOF
}

case &quot;$COMMAND&quot; in
	&quot;configure&quot;)
		configure
		;;
...
esac
</code></pre>
<p><strong>NOTE:</strong> Bash doesn't have an object-oriented API</p>
<h3><a class="header" href="#python-boilerplate" id="python-boilerplate">Python Boilerplate</a></h3>
<pre><code class="language-python">#!/usr/bin/python3

import os
import sys
sys.path.append(&quot;%s/lib&quot; % os.getenv(&quot;GOPHER_INSTALLDIR&quot;))
from gopherbot_v2 import Robot # use _v1 for python2

bot = Robot()

default_config = '''
&lt;yaml config document&gt;
'''

executable = sys.argv.pop(0)
command = sys.argv.pop(0)

if command == &quot;configure&quot;:
    print default_config
...
</code></pre>
<h3><a class="header" href="#ruby-boilerplate" id="ruby-boilerplate">Ruby Boilerplate</a></h3>
<pre><code class="language-ruby">#!/usr/bin/ruby

# boilerplate
require ENV[&quot;GOPHER_INSTALLDIR&quot;] + '/lib/gopherbot_v1'

bot = Robot.new()

defaultConfig = &lt;&lt;'DEFCONFIG'
&lt;yaml config document&gt;
DEFCONFIG

command = ARGV.shift()

case command
when &quot;configure&quot;
	puts defaultConfig
	exit
...
end
</code></pre>
<h1><a class="header" href="#the-plugin-api" id="the-plugin-api">The Plugin API</a></h1>
<p>Gopherbot has a rich set of methods (functions) for interacting with the robot / user. Here we break down the API into sets of related functions:</p>
<ul>
<li><a href="api/Attribute-Retrieval-API.html">Attribute Lookup Methods</a> - for retrieving names, email addresses, etc.</li>
<li><a href="api/Message-Sending-API.html">Sending Messages and Replies</a> - for sending messages to the users</li>
<li><a href="api/Response-Request-API.html">Prompting for Input</a> - for getting replies from the user</li>
<li><a href="api/Brain-API.html">Brain Methods and Memories</a> - for storing and retrieving long- and short-term memories</li>
<li><a href="api/Utility-API.html">Utility Methods</a> - a collection of miscellaneous useful functions, like Pause() and Log()</li>
</ul>
<h1><a class="header" href="#getting-information-about-users-and-the-robot" id="getting-information-about-users-and-the-robot">Getting Information About Users and the Robot</a></h1>
<p>The <code>Get*Attribute(...)</code> family of methods can be used to get basic chat service directory information like first and last name, email address, etc. <code>GetSenderAttribute</code> and <code>GetBotAttribute</code> take a single argument, the name of the attribute to retrieve. The lesser-used <code>GetUserAttribute</code> takes two arguments, the user and the attribute. The return value is an object with <code>Attribute</code> and <code>RetVal</code> members. <code>RetVal</code> will be one of <code>Ok</code>, <code>UserNotFound</code> or <code>AttributeNotFound</code>.</p>
<h2><a class="header" href="#user-attributes" id="user-attributes">User Attributes</a></h2>
<p>The available attributes for a user / sender:</p>
<ul>
<li>name (handle)</li>
<li>fullName</li>
<li>email</li>
<li>firstName</li>
<li>lastName</li>
<li>phone</li>
<li>internalID (protocol internal representatation)</li>
</ul>
<h2><a class="header" href="#bot-attributes" id="bot-attributes">Bot Attributes</a></h2>
<p>The available attributes for the bot:</p>
<ul>
<li>name</li>
<li>alias</li>
<li>fullName / realName</li>
<li>contact / admin / adminContact</li>
<li>email</li>
<li>protocol (e.g. &quot;slack&quot;)</li>
</ul>
<p>Note: the values for most of these are configured in <code>conf/gopherbot.yaml</code></p>
<h1><a class="header" href="#code-examples" id="code-examples">Code Examples</a></h1>
<h2><a class="header" href="#bash" id="bash">Bash</a></h2>
<pre><code class="language-bash">USEREMAIL=$(GetSenderAttribute email)
if [ $? -ne $GBRET_Ok ]
then
  Say &quot;I was unable to look up your email address&quot;
else
  Say &quot;Your email address is $USEREMAIL&quot;
fi
</code></pre>
<h2><a class="header" href="#powershell" id="powershell">PowerShell</a></h2>
<pre><code class="language-powershell">$attr = $bot.GetBotAttribute(&quot;email&quot;)
if ( $attr.Ret -eq &quot;Ok&quot; ) {
  $email = $attr.Attr
  $bot.Say(&quot;My email address is: $email&quot;)
} else {
  $bot.Say(&quot;I don't think I have an email address&quot;)
}
</code></pre>
<h2><a class="header" href="#python" id="python">Python</a></h2>
<pre><code class="language-python"># In some cases you might forego error checking
bot.Say(&quot;You can send email to %s&quot; % bot.GetBotAttribte(&quot;email&quot;))
botNameAttr = bot.GetBotAttribute(&quot;fullName&quot;)
if botNameAttr.ret == Robot.Ok:
  bot.Say(&quot;My full name is %s&quot; % botNameAttr)
else:
  bot.Say(&quot;I don't even know what my name is!&quot;)
</code></pre>
<h2><a class="header" href="#ruby" id="ruby">Ruby</a></h2>
<pre><code class="language-ruby"># In some cases you might forego error checking
bot.Say(&quot;You can send email to #{bot.GetBotAttribute(&quot;email&quot;)}&quot;)
botNameAttr = bot.GetBotAttribute(&quot;fullName&quot;)
if botNameAttr.ret == Robot::Ok
  bot.Say(&quot;My full name is #{botNameAttr}&quot;)
else
  bot.Say(&quot;I don't even know what my name is!&quot;)
end
</code></pre>
<p><strong>Gopherbot</strong> comes with brain methods allowing plugin authors to store information long-term information like a <code>TODO</code> list, or short-term contextual
information, such as a particular list item under discussion. An important supplement to this guide can be found in the example scripting
plugins in the <code>plugins/</code> directory, and the <code>links</code> and <code>lists</code> <em>Go</em> plugins in the <code>goplugins</code> directory (from the source,
not included in the distributed <code>.zip</code> files).</p>
<h1><a class="header" href="#table-of-contents-1" id="table-of-contents-1">Table of Contents</a></h1>
<ul>
<li><a href="api/Brain-API.html#memory-scoping">Memory Scoping</a></li>
<li><a href="api/Brain-API.html#long-term-memories">Long-Term Memories</a>
<ul>
<li><a href="api/Brain-API.html#long-term-memory-code-examples">Code Examples</a></li>
<li><a href="api/Brain-API.html#long-term-memory-sample-transcript">Sample Transcript</a></li>
</ul>
</li>
<li><a href="api/Brain-API.html#short-term-memories">Short-Term Memories</a>
<ul>
<li><a href="api/Brain-API.html#method-summary">Method Summary</a></li>
<li><a href="api/Brain-API.html#short-term-memory-code-examples">Code Examples</a></li>
<li><a href="api/Brain-API.html#short-term-memory-sample-transcript">Sample Transcript</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#memory-scoping" id="memory-scoping">Memory Scoping</a></h1>
<p>Long-term memories are scoped per-plugin by key, and so the data is not shareable between plugins. Short-term memories are stored
for each user/channel combination, and can be freely shared between plugins.</p>
<h1><a class="header" href="#long-term-memories" id="long-term-memories">Long-Term Memories</a></h1>
<p>The following methods are available for manipulating long-term memories:</p>
<ul>
<li><code>CheckoutDatum(key, RWflag)</code> - returns a complex data item (memory) with a short-term exclusive lock on the datum if RW is <code>true</code></li>
<li><code>CheckinDatum(memory)</code> - signals the robot to release the lock without updating</li>
<li><code>UpdateDatum(memory)</code> - updates the memory and releases the lock</li>
</ul>
<h2><a class="header" href="#long-term-memory-code-examples" id="long-term-memory-code-examples">Long-Term Memory Code Examples</a></h2>
<p>The memory stored can be an arbitrarily complex data item; a hash, array, or combination - anything that can be serialized to/from
JSON. The example plugins for <strong>Python</strong>, <strong>Ruby</strong> and <strong>PowerShell</strong> all implement a <em>remember</em> function that remembers a list (array)
of items. For the code examples, we'll start with a memory whose key is <code>memory</code>, and has two items defined by this snippet of JSON:</p>
<pre><code class="language-json">[&quot;the Alamo&quot;, &quot;Ferris Bueller&quot;]
</code></pre>
<p>The examples will check if the memory exists, add &quot;the answer is 42&quot;, and then update the memory.</p>
<p>Note that long-term memory commands aren't current implemented for <code>bash</code>.</p>
<h3><a class="header" href="#python-1" id="python-1">Python</a></h3>
<pre><code class="language-python">memory = bot.CheckoutDatum(&quot;memory&quot;, True)
if memory.exists:
    memory.datum.append(&quot;the answer is 42&quot;)
else:
    memory.datum = [ thing ]
ret = bot.UpdateDatum(memory)
if ret != Robot.Ok:
    bot.Say(&quot;Uh-oh, I must be gettin' old - having memory problems!&quot;)
</code></pre>
<h3><a class="header" href="#ruby-1" id="ruby-1">Ruby</a></h3>
<p>Note: the Ruby example is a little more complicated; adapted from plugins/rubydemo.rb.</p>
<pre><code class="language-ruby">memory = bot.CheckoutDatum(&quot;memory&quot;, true)
remembered = false
if memory.exists
  if memory.datum.include?(thing)
    bot.Say(&quot;That's already one of my fondest memories&quot;)
    bot.CheckinDatum(memory)
  else
    remembered = true
    memory.datum.push(&quot;the answer is 42&quot;)
  end
else
  remembered = true
  memory.datum = [ &quot;the answer is 42&quot; ]
end
if remembered
  ret = bot.UpdateDatum(memory)
  if ret != Robot::Ok
    bot.Say(&quot;Dang it, having problems with my memory&quot;)
  end
end
</code></pre>
<h3><a class="header" href="#powershell-1" id="powershell-1">PowerShell</a></h3>
<pre><code class="language-powershell">$memory = $bot.CheckoutDatum(&quot;memory&quot;, $TRUE)
if ($memory.exists) {
  $memory.Datum += &quot;the answer is 42&quot;
} else {
  [String[]] $memory.Datum = @( &quot;the answer is 42&quot; )
}
$ret = $bot.UpdateDatum($memory)
if ($ret -ne &quot;Ok&quot;) {
  $bot.Say(&quot;I'm having a hard time remembering things&quot;)
}
</code></pre>
<h2><a class="header" href="#long-term-memory-sample-transcript" id="long-term-memory-sample-transcript">Long-Term Memory Sample Transcript</a></h2>
<p>Using the <code>terminal</code> connector, you can see the <code>remember</code> function in action:</p>
<pre><code>c:general/u:alice -&gt; floyd, remember the answer is 42
general: Ok, I'll remember &quot;the answer is 42&quot;
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; floyd, recall
general: Here's everything I can remember:
#1: the Alamo
#2: Ferris Bueller
#3: the answer is 42
</code></pre>
<p>From the transcript you can see that <code>alice</code> added the item to the list, which
was then visible to <code>bob</code>. The <code>links</code> and <code>lists</code> plugins are more useful, and
allow easy sharing of bookmark items or <code>TODO</code> lists, for example.</p>
<h1><a class="header" href="#short-term-memories" id="short-term-memories">Short-Term Memories</a></h1>
<p>Short term memories are simple key -&gt; string values stored for each user / channel combination, and expiring
after a time. The best example of this uses the built-in <code>links</code> and <code>lists</code> plugins, shown in this example
using the <code>terminal</code> plugin:</p>
<pre><code>c:general/u:alice -&gt; link tuna casserole to https://www.allrecipes.com/recipe/17219/best-tuna-casserole/, floyd
general: Link added
c:general/u:alice -&gt; add it to the dinner meals list
c:general/u:alice -&gt; floyd
general: Ok, I added tuna casserole to the dinner meals list
c:general/u:alice -&gt; floyd
general: Yes?
c:general/u:bob -&gt; floyd, pick a random item from the dinner meals list
general: Here you go: tuna casserole
c:general/u:bob -&gt; look it up, floyd
general: Here's what I have for &quot;tuna casserole&quot;:
https://www.allrecipes.com/recipe/17219/best-tuna-casserole/: tuna casserole
</code></pre>
<p>Here, the robot is using short-term memories several times. When I forgot to address my command to the robot, the command
<code>add it to the dinner meals list</code> was stored in short-term memory for user <code>alice</code> in the <code>general</code> channel; then, when
I typed the robot's name, it checked short-term memory for the last thing <code>alice</code> said (stored automatically). Then,
the <code>links</code> plugin stored <code>tuna casserole</code> in the <code>item</code> short-term contextual memory; when I used <code>it</code> in the lists command,
the lists plugin checked the <code>item</code> short-term memory (see <code>contexts</code> in the plugin config for <code>lists</code>) and
substituted the value from the short-term memory.</p>
<h2><a class="header" href="#method-summary" id="method-summary">Method Summary</a></h2>
<p>These methods are available for short-term memories:</p>
<ul>
<li><code>Remember(key, value)</code> - associate the string <code>value</code> to <code>key</code>, always returns <code>Ok</code></li>
<li><code>RememberContext(context, value)</code> - store a short-term contextual memory for use with other plugins</li>
<li><code>Recall(key)</code> - return the short-term memory associated with <code>key</code>, or the empty string when the memory doesn't exist</li>
</ul>
<p>Note that the short-term memory API doesn't have complicated return values. They are always stored in the robot's working
memory and never persisted, and expire after several minutes - so plugins should always be prepared to get blank return
values.</p>
<h2><a class="header" href="#short-term-memory-code-examples" id="short-term-memory-code-examples">Short-Term Memory Code Examples</a></h2>
<p>Note that the short-term memory API is super trivial, so I didn't go to great lengths to provide
detailed examples. The <code>bash</code> example comes from the <code>bashdemo.sh</code> plugin.</p>
<h3><a class="header" href="#bash-1" id="bash-1">Bash</a></h3>
<pre><code class="language-bash">Remember &quot;$1&quot; &quot;$2&quot;
Say &quot;I'll remember \&quot;$1\&quot; is \&quot;$2\&quot; - but eventually I'll forget!&quot;
</code></pre>
<pre><code class="language-bash">MEMORY=$(Recall &quot;$1&quot;)
if [ -z &quot;$MEMORY&quot; ]
then
	Reply &quot;Gosh, I have no idea - I'm so forgetful!&quot;
else
	Say &quot;$1 is $MEMORY&quot;
fi
</code></pre>
<h3><a class="header" href="#python-2" id="python-2">Python</a></h3>
<pre><code class="language-python">bot.Remember(key, value)
</code></pre>
<pre><code class="language-python">mem = bot.Recall(key)
</code></pre>
<h3><a class="header" href="#ruby-2" id="ruby-2">Ruby</a></h3>
<pre><code class="language-ruby">bot.Remember(key, value)
</code></pre>
<pre><code class="language-ruby">mem = bot.Recall(key)
</code></pre>
<h3><a class="header" href="#powershell-2" id="powershell-2">PowerShell</a></h3>
<pre><code class="language-powershell">$bot.Remember($key, $value)
</code></pre>
<pre><code class="language-powershell">$mem = $bot.Recall($key)
</code></pre>
<h2><a class="header" href="#short-term-memory-sample-transcript" id="short-term-memory-sample-transcript">Short-Term Memory Sample Transcript</a></h2>
<p>Here you can see the robot's short term memories of Ferris Bueller in action (using
the <code>bashdemo.sh</code> plugin):</p>
<pre><code>c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: @bob Gosh, I have no idea - I'm so forgetful!
c:general/u:bob -&gt; floyd, store Ferris Bueller is a Righteous Dude
general: I'll remember &quot;Ferris Bueller&quot; is &quot;a Righteous Dude&quot; - but eventually I'll forget!
c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: Ferris Bueller is a Righteous Dude
c:general/u:bob -&gt; |ualice
Changed current user to: alice
c:general/u:alice -&gt; floyd, what is Ferris Bueller
general: @alice Gosh, I have no idea - I'm so forgetful!
c:general/u:alice -&gt; |ubob
Changed current user to: bob
c:general/u:bob -&gt; floyd, what is Ferris Bueller
general: Ferris Bueller is a Righteous Dude
</code></pre>
<h1><a class="header" href="#table-of-contents-2" id="table-of-contents-2">Table of Contents</a></h1>
<ul>
<li><a href="api/Message-Sending-API.html#message-formatting">Message Formatting</a></li>
<li><a href="api/Message-Sending-API.html#say-and-reply">Say and Reply</a></li>
<li><a href="api/Message-Sending-API.html#sendusermessage-sendchannelmessage-and-senduserchannelmessage">SendUserMessage, SendChannelMessage and SendUserChannelMessage</a></li>
<li><a href="api/Message-Sending-API.html#code-examples">Code Examples</a>
<ul>
<li><a href="api/Message-Sending-API.html#bash">Bash</a></li>
<li><a href="api/Message-Sending-API.html#powershell">PowerShell</a></li>
<li><a href="api/Message-Sending-API.html#python">Python</a></li>
<li><a href="api/Message-Sending-API.html#ruby">Ruby</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#messageformat-method-and-message-formatting" id="messageformat-method-and-message-formatting">MessageFormat method and Message Formatting</a></h1>
<p><strong>Gopherbot</strong> is designed to provide ChatOps functionality for a variety of team
chat platforms, with Slack being the first. Due to the technical nature of ChatOps,
characters like <code>_</code>, <code>*</code> and ` may need to be rendered in replies to the user;
at times omitting these characters (because they cause formatting changes) could
remove important information. To provide the plugin author with the most flexibility,
<strong>Gopherbot</strong> supports the notion of three message formats:</p>
<ul>
<li><code>Raw</code> - text sent by a plugin with <code>Raw</code> format is passed straight to the chat platform as-is; this is the default if no other default is specified</li>
<li><code>Variable</code> - for the <code>Variable</code> format, the protocol connector should attempt to process the message so that special characters are escaped or otherwise modified to render for the user in a standard variable-width font; for Slack, special characters are surrounded by nulls</li>
<li><code>Fixed</code> - the protocol connector should render <code>Fixed</code> format messages in a fixed-width block format</li>
</ul>
<p>The <code>MessageFormat(raw|variable|fixed)</code> method returns a robot object with the specified format. A plugin can use
<code>GetBotAttribute(&quot;protocol&quot;)</code> to determine the connector protocol (e.g. &quot;slack&quot;) to make intelligent decisions
about the format to use, or modify the content of raw messages depending on the connection protocol.</p>
<h1><a class="header" href="#say-and-reply" id="say-and-reply">Say and Reply</a></h1>
<p><code>Say</code> and <code>Reply</code> are the staples of message sending. Both are generally used for replying to the person who spoke to the robot, but <code>Reply</code> will also <em>mention</em> the user. Normally, <code>Say</code> is used when the robot responds immediately to the user, but <code>Reply</code> is used when the robot is performing a task that takes more than a few minutes, and the robot needs to direct the message to the user to update them with progress on the task. Both <code>Say</code> and <code>Reply</code> take a <code>message</code> argument, and an optional second <code>format</code> argument that can be <code>variable</code> (the default) for variable-width text, or <code>fixed</code> for fixed-width text. The <code>fixed</code> format is normally used with embedded newlines to create tabular output where the columns will line up. The return value is not normally checked, but can be one of <code>Ok</code>, <code>UserNotFound</code>, <code>ChannelNotFound</code>, or <code>FailedMessageSend</code>.</p>
<h1><a class="header" href="#sendusermessage-sendchannelmessage-and-senduserchannelmessage" id="sendusermessage-sendchannelmessage-and-senduserchannelmessage">SendUserMessage, SendChannelMessage and SendUserChannelMessage</a></h1>
<p><code>Say</code> and <code>Reply</code> are actually convenience wrappers for the <code>Send*Message</code> family of methods. <code>SendChannelMessage</code> takes the obvious arguments of <code>channel</code> and <code>message</code> and just writes a message to a channel. <code>SendUserMessage</code> sends a direct message to a user, and <code>SendUserChannelMessage</code> directs the message to a user in a channel by using a connector-specific <em>mention</em>. Like <code>Say</code> and <code>Reply</code>, each of these functions also takes an optional <code>format</code> argument, and uses the same return values.</p>
<h1><a class="header" href="#code-examples-1" id="code-examples-1">Code Examples</a></h1>
<h2><a class="header" href="#bash-2" id="bash-2">Bash</a></h2>
<pre><code class="language-bash"># Note that bash isn't object-oriented
Say &quot;I'm sending a message to Bob in #general&quot;
SendUserChannelMessage &quot;bob&quot; &quot;general&quot; &quot;Hi, Bob!&quot;
RETVAL = $?
if [ $RETVAL -ne $GBRET_Ok ]
then
  Log &quot;Error&quot; &quot;Unable to message Bob in #general - return code $RETVAL&quot;
fi
</code></pre>
<h2><a class="header" href="#powershell-3" id="powershell-3">PowerShell</a></h2>
<pre><code class="language-powershell">$bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
$retval = $bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if ( $retval -ne &quot;Ok&quot; ) {
  $bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code $retval&quot;)
}
</code></pre>
<h2><a class="header" href="#python-3" id="python-3">Python</a></h2>
<pre><code class="language-python">bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
retval = bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if ( retval != Robot.Ok ):
  bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code %d&quot; % retval)
</code></pre>
<h2><a class="header" href="#ruby-3" id="ruby-3">Ruby</a></h2>
<pre><code class="language-ruby">bot.Say(&quot;I'm sending a message to Bob in #general&quot;)
retval = bot.SendUserChannelMessage(&quot;bob&quot;, &quot;general&quot;, &quot;Hi, Bob!&quot;)
if retval != Robot::Ok
  bot.Log(&quot;Error&quot;, &quot;Unable to message Bob in #general - return code %d&quot; % retval)
end
</code></pre>
<p><strong>Gopherbot</strong> takes a slightly different approach to creating pipelines; pipelines are created by Add/Fail/Final Job/Command/Task family of methods, rather than by fixed configuration directives. This allows flexible configuration of pipelines if desired for e.g. a CI/CD application, or dynamic generation of pipelines based on logic at runtime.</p>
<p>Until more documentation is written, see:</p>
<ul>
<li><a href="https://github.com/lnxjedi/gopherbot/blob/master/.gopherci/pipeline.sh">The Gopherbot Pipeline Source</a></li>
<li><a href="https://github.com/parsley42/floyd-gopherbot">The Configuration repository for Floyd, the robot that builds Gopherbot</a></li>
</ul>
<h1><a class="header" href="#table-of-contents-3" id="table-of-contents-3">Table of Contents</a></h1>
<ul>
<li><a href="api/Pipeline-API.html#addtask">AddTask</a></li>
<li><a href="api/Pipeline-API.html#setparameter">SetParameter</a></li>
</ul>
<h2><a class="header" href="#addtask" id="addtask">AddTask</a></h2>
<p>The <code>AddTask</code> method ... TODO: finish me!</p>
<h3><a class="header" href="#bash-3" id="bash-3">Bash</a></h3>
<pre><code class="language-bash">AddTask &quot;echo&quot; &quot;hello, world&quot;
</code></pre>
<h3><a class="header" href="#python-4" id="python-4">Python</a></h3>
<pre><code class="language-python"></code></pre>
<h3><a class="header" href="#ruby-4" id="ruby-4">Ruby</a></h3>
<pre><code class="language-ruby"></code></pre>
<h3><a class="header" href="#powershell-4" id="powershell-4">PowerShell</a></h3>
<pre><code class="language-powershell">$ret = $bot.AddTask(&quot;echo&quot;, @(&quot;hello&quot;, &quot;world&quot;))
</code></pre>
<h2><a class="header" href="#setparameter" id="setparameter">SetParameter</a></h2>
<p>The <code>Prompt*ForReply</code> methods make it simple to write interactive plugins where the bot can request additional input from the user.</p>
<h1><a class="header" href="#table-of-contents-4" id="table-of-contents-4">Table of Contents</a></h1>
<ul>
<li><a href="api/Response-Request-API.html#technical-background">Technical Background</a></li>
<li><a href="api/Response-Request-API.html#prompting-methods">Prompting Methods</a>
<ul>
<li><a href="api/Response-Request-API.html#method-arguments">Method Arguments</a></li>
<li><a href="api/Response-Request-API.html#return-values">Return Values</a></li>
</ul>
</li>
<li><a href="api/Response-Request-API.html#code-examples">Code Examples</a>
<ul>
<li><a href="api/Response-Request-API.html#bash">Bash</a></li>
<li><a href="api/Response-Request-API.html#powershell">PowerShell</a></li>
<li><a href="api/Response-Request-API.html#python">Python</a></li>
<li><a href="api/Response-Request-API.html#ruby">Ruby</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#technical-background" id="technical-background">Technical Background</a></h2>
<p>Interactive plugins are complicated by the fact that multiple plugins can be running simultaneously and each can request input from the user. <strong>Gopherbot</strong> handles requests for replies this way:</p>
<ol>
<li>If there are no other plugins waiting for a reply for the given user/channel, the robot emits the prompt and waits to hear back from the user</li>
<li>If other plugins are waiting for a reply, the prompt is not emitted and the request goes in to a list of waiters</li>
<li>As other plugins get replies (or timeout while waiting), waiters in the list get a <code>RetVal</code> of <code>RetryPrompt</code>, indicating they should issue the prompt request again (this is handled internally in individual scripting libraries)</li>
</ol>
<h2><a class="header" href="#prompting-methods" id="prompting-methods">Prompting Methods</a></h2>
<p>The following methods are available for prompting for replies:</p>
<ul>
<li><code>PromptForReply(regexID string, prompt string)</code> - issue a prompt to whoever/wherever the original command was issued</li>
<li><code>PromptUserForReply(regexID string, user string, prompt string)</code> - for prompting the user in a direct message (DM) (for e.g. a password or other sensitive information)</li>
<li><code>PromptUserChannelForReply(regexID string, user string, channel string, prompt string)</code> - prompt a specific user in a specific channel (for e.g. getting approval from another user for an action)</li>
</ul>
<h3><a class="header" href="#method-arguments" id="method-arguments">Method arguments</a></h3>
<p>The <code>user</code> and <code>channel</code> arguments are obvious; the <code>prompt</code> is the question the robot is
asking the user, and should usually end with a <code>?</code>.</p>
<p>The <code>regexID</code> should correspond to a <code>ReplyMatcher</code> defined in the plugin configuration,
(see <a href="api/Configuration.html#plugin-configuration">Plugin Configuration</a>), or one of the
built-in regex's:</p>
<ul>
<li><code>Email</code></li>
<li><code>Domain</code> - an alpha-numeric domain name</li>
<li><code>OTP</code> - a 6-digit one-time password code</li>
<li><code>IPAddr</code></li>
<li><code>SimpleString</code> - Characters commonly found in most english sentences, doesn't include special characters like @, {, etc.</li>
<li><code>YesNo</code></li>
</ul>
<h3><a class="header" href="#return-values" id="return-values">Return Values</a></h3>
<p>Two distinct values are returned from the prompting methods:</p>
<ol>
<li>A <code>RetVal</code> indicating success or error condition - <code>Reply.ret</code></li>
<li>When <code>RetVal</code> == <code>Ok</code>, the matched string is also returned - <code>Reply.reply</code></li>
</ol>
<p>In <strong>Go</strong>, these are returned as two separate values; in most scripting
languages, these are returned as a compound object whose string representation
is the returned string in <code>Reply.reply</code> (if the <code>RetVal</code> was <code>Ok</code>, otherwise it's the empty string).</p>
<p>Possible values for the <code>RetVal</code> in <code>Reply.ret</code> are:</p>
<ul>
<li><code>Ok</code> - If the user replied and the reply matched the regex identified by <code>regexID</code></li>
<li><code>UserNotFound</code>, <code>ChannelNotFound</code> - When an invalid user / channel is provided</li>
<li><code>MatcherNotFound</code> - When an invalid matcher is supplied</li>
<li><code>Interrupted</code> - If the user issues a new command to the robot (see NOTE below), too many <code>RetryPrompt</code> values are returned (&gt;3), or the user replies with a single dash: '<code>-</code>' (cancel)</li>
<li><code>TimeoutExpired</code> - If the user says nothing for 45 seconds</li>
<li><code>UseDefaultValue</code> - If the user replied with a single equal sign (<code>=</code>)</li>
<li><code>ReplyNotMatched</code> - When the reply from the user didn't match the supplied regex (the user was probably talking to somebody else)</li>
</ul>
<h2><a class="header" href="#code-examples-2" id="code-examples-2">Code Examples</a></h2>
<h3><a class="header" href="#bash-4" id="bash-4">Bash</a></h3>
<pre><code class="language-bash"># Note that bash isn't object-oriented
REPLY=$(PromptForReply &quot;YesNo&quot; &quot;Do you like kittens?&quot;)
if [ $? -ne 0 ]
then
	Reply &quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;
else
  if [[ $REPLY == y* ]] || [[ $REPLY == Y* ]]
  then
    Say &quot;No kidding! Me too!&quot;
  else
    Say &quot;Oh, come on - you're kidding, right?!?&quot;
  fi
fi
</code></pre>
<h3><a class="header" href="#powershell-5" id="powershell-5">PowerShell</a></h3>
<pre><code class="language-powershell">$rep = $bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if ($rep.Ret -ne &quot;Ok&quot;) {
  $bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
} else {
  $reply = [String]$rep
  switch -Wildcard ($reply) {
    &quot;y*&quot; { # PS is case-insensitive
      $bot.Say(&quot;No kidding! Me too!&quot;)
    }
    default {
      $bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
    }
  }
}
</code></pre>
<h3><a class="header" href="#python-5" id="python-5">Python</a></h3>
<pre><code class="language-python">rep = bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if rep.ret != Robot.Ok:
  bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
else:
  reply = rep.__str__()
  if re.match(&quot;y.*&quot;, reply, flags=re.IGNORECASE):
    bot.Say(&quot;No kidding! Me too!&quot;)
  else:
    bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
</code></pre>
<h3><a class="header" href="#ruby-5" id="ruby-5">Ruby</a></h3>
<pre><code class="language-ruby">rep = bot.PromptForReply(&quot;YesNo&quot;, &quot;Do you like kittens?&quot;)
if rep.ret != Robot::Ok
  bot.Say(&quot;Eh, sorry bub, I'm having trouble hearing you - try typing faster?&quot;)
else
  reply = rep.to_s()
  if /y.*/i =~ reply
    bot.Say(&quot;No kidding! Me too!&quot;)
  else
    bot.Say(&quot;Oh, come on - you're kidding, right?!?&quot;)
  end
end
</code></pre>
<h1><a class="header" href="#log-method" id="log-method">Log Method</a></h1>
<p>Besides the logging that Gopherbot does on it's own, plugins can also emit log messages with one of the following log levels:</p>
<ul>
<li><code>Trace</code> - for fine-grained logging of all actions</li>
<li><code>Debug</code> - for emitting debugging info</li>
<li><code>Info</code> - the default log level</li>
<li><code>Audit</code> - for auditable events - <strong>NOTE:</strong> <em>Audit events are always logged regardless of the current log level</em></li>
<li><code>Warn</code> - for potentially harmful events</li>
<li><code>Error</code> - for errors</li>
<li><code>Fatal</code> - emit fatal error and cause robot to exit(1)</li>
</ul>
<h2><a class="header" href="#bash-5" id="bash-5">Bash</a></h2>
<pre><code class="language-bash">Log &quot;Error&quot; &quot;The robot broke&quot;
</code></pre>
<h2><a class="header" href="#powershell-6" id="powershell-6">PowerShell</a></h2>
<pre><code class="language-powershell">$bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h2><a class="header" href="#python-6" id="python-6">Python</a></h2>
<pre><code class="language-python">bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h2><a class="header" href="#ruby-6" id="ruby-6">Ruby</a></h2>
<pre><code class="language-ruby">bot.Log(&quot;Error&quot;, &quot;The robot broke&quot;)
</code></pre>
<h1><a class="header" href="#pause-method" id="pause-method">Pause Method</a></h1>
<p>Every language has some means of sleeping / pausing, and this method is provided as a convenience to plugin authors and implemented natively. It takes a single argument, time in seconds.</p>
<h2><a class="header" href="#bash-6" id="bash-6">Bash</a></h2>
<pre><code class="language-bash">Say &quot;Be back soon!&quot;
Pause 2
Say &quot;... aaaand I'm back!&quot;
</code></pre>
<h2><a class="header" href="#powershell-7" id="powershell-7">PowerShell</a></h2>
<pre><code class="language-powershell">$bot.Say(&quot;Be back soon!&quot;)
$bot.Pause(2)
$bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2><a class="header" href="#python-7" id="python-7">Python</a></h2>
<pre><code class="language-python">bot.Say(&quot;Be back soon!&quot;)
bot.Pause(2)
bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2><a class="header" href="#ruby-7" id="ruby-7">Ruby</a></h2>
<pre><code class="language-ruby">bot.Say(&quot;Be back soon!&quot;)
bot.Pause(2)
bot.Say(&quot;... aaaand I'm back!&quot;)
</code></pre>
<h2><a class="header" href="#gopherbot-loadable-module-support" id="gopherbot-loadable-module-support">Gopherbot Loadable Module Support</a></h2>
<p><strong>Gopherbot's</strong> loadable module support now allows new or updated <strong>Go</strong> plugins to be loaded in to a running robot (though it requires a full restart).</p>
<h1><a class="header" href="#tool-integrations" id="tool-integrations">Tool Integrations</a></h1>
<p>To simplify using tools like <code>ssh</code> and <code>ansible</code> in your pipeline, <strong>Gopherbot</strong> ships with some predefined pipeline elements detailed in the following sections.</p>
<h1><a class="header" href="#integrating-with-ssh" id="integrating-with-ssh">Integrating with SSH</a></h1>
<p>The <strong>GopherCI</strong> job(s) use <em>ssh</em> tasks for cloning repositories with public keys, and you can also use these tasks in your own pipelines for executing remote tasks.</p>
<h2><a class="header" href="#configuring-ssh" id="configuring-ssh">Configuring SSH</a></h2>
<p>You start by choosing a passphrase for your robot's ssh keypair - make it something quite long; you shouldn't need to type it more than once. Use the <code>encrypt</code> command (normally with the terminal connector) to produce the encrypted value, and put it in a stanza like the following in your <code>gopherbot.yaml</code>:</p>
<pre><code class="language-yaml">ExternalTasks:
  &quot;ssh-init&quot;:
    Parameters:
    - Name: BOT_SSH_PHRASE
      Value: {{ decrypt &quot;xxxxx&quot; }}
</code></pre>
<h2><a class="header" href="#initializing" id="initializing">Initializing</a></h2>
<p>Once the robot knows it's passphrase, you can use the <code>generate keypair</code> administrator command to generate a new keypair, which will be stored in <code>$GOPHER_CONFIGDIR/ssh/</code>. The private key is encrypted with the robot's (also encrypted) passphrase, so this can be committed to the repository. The <code>pubkey</code> administrator command will display the robot's public key.</p>
<h2><a class="header" href="#using-in-pipelines" id="using-in-pipelines">Using in Pipelines</a></h2>
<p>A pipeline using <em>ssh</em> might look something like this:</p>
<pre><code class="language-bash">AddTask ssh-init

AddTask ssh-scan my.remote.host

AddTask exec ssh $SSH_OPTIONS user@my.remote.host &quot;whoami&quot;
</code></pre>
<ul>
<li>The <code>ssh-init</code> task will:
<ul>
<li>Start an <code>ssh-agent</code> and add the robot's key</li>
<li>Use <code>SetParameter</code> to store <code>SSH_AUTH_SOCK</code> and <code>SSH_AGENT_PID</code> in the pipeline</li>
<li>Set <code>SSH_OPTIONS</code> to e.g. <code>-F $GOPHER_CONFIGDIR/ssh/config</code> if the robot has a custom ssh config file</li>
<li>Add a <strong>FinalTask</strong> to kill the <code>ssh-agent</code> when the pipeline finishes</li>
</ul>
</li>
<li><code>ssh-scan</code> insures a host is listed in <code>known_hosts</code>, if desired (this may be unneeded depending on the contents of <code>ssh/config</code>)</li>
<li>The <code>exec</code> task calls ssh as normal, using <code>$SSH_OPTIONS</code> to pick up custom configuration if it exists</li>
</ul>
<h1><a class="header" href="#working-on-gopherbot" id="working-on-gopherbot">Working on Gopherbot</a></h1>
<p>This chapter outlines the tools and methods for working on <strong>Gopherbot</strong> itself.</p>
<h1><a class="header" href="#development-robot" id="development-robot">Development Robot</a></h1>
<h1><a class="header" href="#developing-integration-tests" id="developing-integration-tests">Developing Integration Tests</a></h1>
<p>The current testing methodology for <strong>Gopherbot</strong> uses a special <code>test</code> protocol connector for sending test commands to the engine from various users in various channels, and then examining the responses and events generated. The tests themselves and test configurations are located in <code>/test</code>.</p>
<h2><a class="header" href="#building-the-special-testbot" id="building-the-special-testbot">Building the special &quot;testbot&quot;</a></h2>
<p>The <strong>Gopherbot</strong> <code>Makefile</code> includes a special &quot;testbot&quot; target that builds the robot with a modified version of the terminal connector:</p>
<pre><code class="language-shell">$ make testbot
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -mod vendor -tags 'netgo osusergo static_build test' -o gopherbot
</code></pre>
<h2><a class="header" href="#developing-tests" id="developing-tests">Developing Tests</a></h2>
<p>See the contents of <code>test/*_test.go</code> for the format of the tests. After any given exchange with the robot, pressing <code>&lt;enter&gt;</code> by itself gives the events generated. Here's an example session for developing the tests in <code>test/bot_integration_test.go:TestPrompting</code>:</p>
<pre><code class="language-shell">$ make testbot
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -mod vendor -tags 'netgo osusergo static_build test' -o gopherbot
[gopherbot]$ cd test/membrain
[membrain]$ ../../gopherbot 
Terminal connector running; Use '|c&lt;channel|?&gt;' to change channel, or '|u&lt;user|?&gt;' to change user
...
</code></pre>
<h2><a class="header" href="#debugging-deadlocks" id="debugging-deadlocks">Debugging Deadlocks</a></h2>
<p>Occasionally locking changes in the core may result in deadlocks, which should hopefully be detected by the test suite. To assist in debugging these, the <code>SIGTERM</code> handler changes for the <code>test</code> build tag, causing the robot to perform a full stack dump and panic. Note that if an actual robot deadlocks, it should still accept an <code>abort</code> command from an administrator, which will trigger the same behavior.</p>
<p>If <code>make test</code> hangs, you can trigger a stack dump with <code>&lt;ctrl-c&gt;</code>; here's an example where updated locking of the <code>botContext</code> struct introduced a deadlock in the <code>reload</code> command:</p>
<pre><code class="language-shell">$ make test
...
=== RUN   TestReload
# Test hung here, &lt;ctrl-c&gt;
goroutine 631 [running]:
github.com/lnxjedi/gopherbot/bot.sigHandle(0xc0000a1f20)
        /home/davidparsley/git/gopherbot/bot/signal_testing.go:24 +0x243
created by github.com/lnxjedi/gopherbot/bot.run
        /home/davidparsley/git/gopherbot/bot/bot_process.go:310 +0x3e4
...
goroutine 590 [semacquire]:
sync.runtime_SemacquireMutex(0xc000358504, 0x900000000, 0x1)
        /usr/local/go/src/runtime/sema.go:71 +0x47
sync.(*Mutex).lockSlow(0xc000358500)
        /usr/local/go/src/sync/mutex.go:138 +0x1c1
sync.(*Mutex).Lock(0xc000358500)
        /usr/local/go/src/sync/mutex.go:81 +0x7d
github.com/lnxjedi/gopherbot/bot.Robot.getLockedContext(0xc00016e540, 0x81, 0x0)
        /home/davidparsley/git/gopherbot/bot/robot.go:25 +0x4e
github.com/lnxjedi/gopherbot/bot.Robot.Reply(0xc00016e540, 0x81, 0xbf0ee6, 0x23, 0x0, 0x0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/robot_connector_methods.go:212 +0x121
github.com/lnxjedi/gopherbot/bot.admin(0xce2020, 0xc0001ff930, 0xc0000b6320, 0x6, 0xc0001fedb0, 0x0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/builtins.go:345 +0x16b2
github.com/lnxjedi/gopherbot/bot.(*botContext).callTaskThread(0xc000358500, 0xc0003df6e0, 0xb0ef20, 0xc00012a180, 0xc0000b6320, 0x6, 0xc0001fedb0, 0x0, 0x0)
        /home/davidparsley/git/gopherbot/bot/calltask.go:138 +0xb64
created by github.com/lnxjedi/gopherbot/bot.(*botContext).callTask
        /home/davidparsley/git/gopherbot/bot/calltask.go:75 +0xe8
...
panic: Tests terminated by signal terminated

goroutine 631 [running]:
github.com/lnxjedi/gopherbot/bot.sigHandle(0xc0000a1f20)
        /home/davidparsley/git/gopherbot/bot/signal_testing.go:27 +0x37a
created by github.com/lnxjedi/gopherbot/bot.run
        /home/davidparsley/git/gopherbot/bot/bot_process.go:310 +0x3e4
FAIL    github.com/lnxjedi/gopherbot/test       58.197s
FAIL
Makefile:52: recipe for target 'test' failed
make: *** [test] Error 1
</code></pre>
<p>In this case the lock on the <code>botContext</code> was first aquired at the top of the admin <code>reload</code> built-in command, and then hung later when trying to acquire the lock in the robot <code>Reply</code> method.</p>
<h1><a class="header" href="#coding-with-gitpod" id="coding-with-gitpod">Coding with Gitpod</a></h1>
<h1><a class="header" href="#important-structs-and-interfaces" id="important-structs-and-interfaces">Important Structs and Interfaces</a></h1>
<h2><a class="header" href="#the-robot-package" id="the-robot-package">The <code>robot</code> package</a></h2>
<p>The <code>robot</code> package defines structs and interfaces for <strong>Go</strong> tasks, plugins and jobs.</p>
<h3><a class="header" href="#the-robot-interface" id="the-robot-interface">The <code>Robot</code> interface</a></h3>
<p><code>Robot</code> defines the methods available to a <strong>Go</strong> task, plugin or job. Whenever the engine calls a handler for one of these, the first argument to the handler is always an object that implements the <code>Robot</code> interface. Internally (in the <code>bot</code> package), this is a <code>bot.Robot</code> struct, with methods that implement the <code>robot.Robot</code> interface.</p>
<h3><a class="header" href="#the-message-struct" id="the-message-struct">The <code>Message</code> struct</a></h3>
<p>The <code>GetMessage()</code> method on the <code>Robot</code> will return a <code>robot.Message</code>, which contains information about the user and channel, as well as a pointer to a copy of the original incoming data structure from the external connector. The complete definition is available from <a href="https://godoc.org/github.com/lnxjedi/gopherbot/robot#Message">godoc.org</a>.</p>
<h2><a class="header" href="#the-bot-package" id="the-bot-package">The <code>bot</code> package</a></h2>
<p>The <code>bot</code> package contains all the logic for a running robot.</p>
<h3><a class="header" href="#pipelines" id="pipelines">Pipelines</a></h3>
<p>Any time <strong>Gopherbot</strong> runs a task, plugin or job, it is part of a pipeline (which may consist only of a single job or plugin executing). The data structures for representing a pipeline are the <code>worker</code> and the <code>pipeContext</code>.</p>
<h3><a class="header" href="#workers" id="workers">Workers</a></h3>
<p>The <code>worker</code> struct represents a thread of execution. The worker contains all the invariant information about how it was created, whether from an incoming message, a scheduled job, or a job spawn from another worker. Workers are created for every incoming message, regardless of whether a pipeline is ever started. The worker includes a <code>context</code> pointer that is populated when <code>startPipeline(...)</code> is called.</p>
<h3><a class="header" href="#pipe-context" id="pipe-context">Pipe Context</a></h3>
<p>Whenever a pipeline is started, the <code>context</code> member of the <code>worker</code> struct is populated with a <code>pipeContext</code> (by <code>bot.registerActive</code>), to keep state for the pipeline. At this time four bytes of entropy are consumed for the <code>GOPHER_CALLER_ID</code> environment variable, to be passed to external scripts that run in the pipeline. This allows <code>bot/http.go</code> to look up the correct robot on each external script method call. The <code>pipeContext</code> contains a <code>sync.Mutex</code> member for locking, as it can be changed in different threads of execution. Note, however, that a well written task, plugin or job is not multi-threaded, and under normal circumstances all access to the <code>pipeContext</code> <em>should</em> be serialized.</p>
<h3><a class="header" href="#robots" id="robots">Robots</a></h3>
<p>The <code>bot.Robot</code> struct is created any time a task, plugin or job is run, and contains a pointer to the <code>robot.Message</code>, a pointer to the <code>bot.worker</code>, and a snapshot of the current <code>pipeContext</code> when <code>w.makeRobot</code> was called.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
